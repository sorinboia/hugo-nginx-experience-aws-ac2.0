[
{
	"uri": "/010_intro/005_workshop_path/",
	"title": "AWS Workshop environment",
	"tags": [],
	"description": "",
	"content": "There are two ways of doing the workshop, as part of an AWS event or on your own. Please click the relevant path.\n AWS Workshop On your own  "
},
{
	"uri": "/",
	"title": "Nginx Experience",
	"tags": [],
	"description": "",
	"content": "Welcome to AWS NGINX Meetup – From Application code to Customer Delivering modern applications has upped the needs to provide agile application services free from infrastructure constrains, while ensuring applications run faster, secured and at scale. Choosing the right architecture for application services allows organizations to innovate faster and role new services on any infrastructure or cloud architecture. From code development to customer consumption, NGINX deployed on AWS is helping millions of organizations deliver application infrastructure and services ensuring their application are fast, secure and run at scale.\nIntro to the workshop In this workshop you will experience how to deploy your application in an agile way, using NGINX Controller utilizing AWS compute, applying all the application services needed, such as load balancing, API management and application firewall in a fully automated way.\nDeploy NGINX infrastructure using Terraform Start by using automation and use Infrastructure as Code concepts to deploy the environment.\nDeploy your application with NGINX Unit Application Server Easley manage your application deployment lifecycle with the Nginx Unit Application Server\nIncrease availability, security and application performance with Kubernetes Nginx Ingress  Onboard with Caching and Load Balancing Deliver your application faster, using caching and compression to free application resources and improve user’s experience Intro to OpenTracing benefits Open Tracing provides the ability to monitor and resolve issues much faster when your application architecture becomes more complex Zero Trust - Applying Mutual TLS authentication with NGINX  The Nginx Controller  Publish the application APIs with NGINX Micro Gateway Deploy and publish your API endpoints with NGINX Micro Gateway within your Kubernetes environment Enhance APIs with JWT or Access Key token authentication Offload API authentication processes to your API gateway and concentrate Apply API rate limit and spike arrest Protect your APIs from abuse and enforce monetization controls Monitor your application performance Discover your application performance, understand and react when application SLAs are impacted  Security Secure you application with Nginx App Protect Web Application Firewall. Protect you application from fraudulent interactions and separate legitimate traffic from unwanted one with Nginx App Protect Web Application Firewall.\n"
},
{
	"uri": "/010_intro/aws_event/",
	"title": "...at an AWS event",
	"tags": [],
	"description": "",
	"content": "Running the workshop at an AWS Event Only complete this section if you are at an AWS hosted event (such as re:Invent, Kubecon, Immersion Day, or any other event hosted by an AWS employee). If you are running the workshop on your own, go to:\nStart the workshop on your own.\n\r"
},
{
	"uri": "/010_intro/selfpaced/",
	"title": "...on your own",
	"tags": [],
	"description": "",
	"content": "Running the workshop on your own Only complete this section if you are running the workshop on your own. If you are at an AWS hosted event (such as re:Invent, Kubecon, Immersion Day, etc), go to Start the workshop at an AWS event.\n\r"
},
{
	"uri": "/060_controller/010_accessing_controller/",
	"title": "Accessing the Nginx Controller",
	"tags": [],
	"description": "",
	"content": " The Nginx Controller has already been deployed with the terraform declaration, we need to find the public IP address.  cd terraform\rexport controller_ip=$(terraform state show \u0026quot;aws_instance.controller\u0026quot; | grep \u0026quot;public_ip\u0026quot; | grep -v \u0026quot;associate_public_ip_address\u0026quot; | cut -d'\u0026quot;' -f2)\rcurl -k -c cookie.txt -X POST --url \u0026quot;https://$controller_ip/api/v1/platform/login\u0026quot; --header 'Content-Type: application/json' --data '{\u0026quot;credentials\u0026quot;: {\u0026quot;type\u0026quot;: \u0026quot;BASIC\u0026quot;,\u0026quot;username\u0026quot;: \u0026quot;nginx@f5.com\u0026quot;,\u0026quot;password\u0026quot;: \u0026quot;Admin2020\u0026quot;}}'\rexport controller_apikey=$(curl -k -sb cookie.txt -c cookie.txt https://$controller_ip/api/v1/platform/global | jq .currentStatus.agentSettings.apiKey | tr -d '\u0026quot;')\rterraform state show \u0026quot;aws_instance.controller\u0026quot; | grep \u0026quot;public_ip\u0026quot; | grep -v \u0026quot;associate_public_ip_address\u0026quot; | cut -d'\u0026quot;' -f2\rcd ..\rBrowse (using HTTPS) to the IP address of the Controller and verify you have access:  Username (email): nginx@f5.com\nPassword: Admin2020\n\r"
},
{
	"uri": "/030_application/010_app_deployment_1/",
	"title": "App deployment",
	"tags": [],
	"description": "",
	"content": " Deploy the app  kubectl apply -f files/5ingress/1arcadia_delpoy.yaml\rOutput\ndeployment.apps/arcadia-db created\rservice/arcadia-db created\rdeployment.apps/arcadia-frontend created\rservice/arcadia-frontend created\rdeployment.apps/arcadia-login created\rservice/arcadia-login created\rdeployment.apps/arcadia-stock-transaction created\rservice/arcadia-stock-transaction created\rdeployment.apps/arcadia-stocks created\rservice/arcadia-stocks created\rdeployment.apps/arcadia-users created\rservice/arcadia-users created\r Check that all is deployed and working as expected:  kubectl get pods\rOutput\nNAME READY STATUS RESTARTS AGE\rarcadia-db-696f979799-sdzb6 1/1 Running 0 36s\rarcadia-frontend-57ff4f888-v4ggh 1/1 Running 0 36s\rarcadia-login-c995f8dcc-7gvvp 1/1 Running 0 35s\rarcadia-stock-transaction-b996cddb9-xzckf 1/1 Running 0 34s\rarcadia-stocks-dd58548f7-k7tg7 1/1 Running 0 34s\rarcadia-users-768dddd844-8s75q 1/1 Running 0 33s\r kubectl get svc -owide\rOutput\nNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTOR\rarcadia-db ClusterIP 172.20.180.18 \u0026lt;none\u0026gt; 27017/TCP 74s app=arcadia-db\rarcadia-frontend ClusterIP 172.20.11.202 \u0026lt;none\u0026gt; 80/TCP 73s app=arcadia-frontend\rarcadia-login ClusterIP 172.20.247.63 \u0026lt;none\u0026gt; 80/TCP 73s app=arcadia-login\rarcadia-stock-transaction ClusterIP 172.20.155.246 \u0026lt;none\u0026gt; 80/TCP 72s app=arcadia-stock-transaction\rarcadia-stocks ClusterIP 172.20.23.237 \u0026lt;none\u0026gt; 80/TCP 71s app=arcadia-stocks\rarcadia-users ClusterIP 172.20.73.208 \u0026lt;none\u0026gt; 80/TCP 71s app=arcadia-users\rkubernetes ClusterIP 172.20.0.1 \u0026lt;none\u0026gt; 443/TCP 7m2s \u0026lt;none\u0026gt;  The application is not accessible yet. We will deploy the NGINX Ingress in the following sections.\n\r"
},
{
	"uri": "/010_intro/aws_event/010_aws_wokshop_portal_1/",
	"title": "AWS Workshop Portal",
	"tags": [],
	"description": "",
	"content": "This workshop creates an AWS account and a Cloud9 environment. You will need the Participant Hash provided upon entry, and your email address to track your unique session.\n Connect to the portal by clicking the button or browsing to https://dashboard.eventengine.run/. The following screen shows up.  Enter the provided hash in the text box. The button on the bottom right corner changes to Accept Terms \u0026amp; Login. Click on that button to continue.  Click on AWS Console on dashboard.  Accept the defaults and make sure the region is eu-central-1. Click on Open AWS Console. This will open AWS Console in a new browser tab.  "
},
{
	"uri": "/040_ingress/010_ingress_install_1/",
	"title": "Nginx Kubernetes Ingress Installation",
	"tags": [],
	"description": "",
	"content": "We are going to use the Nginx installation manifests based on the Nginx Ingress Controller installation guide. For simplicity - we have already prepared the installation in a single yaml file.\n Run the command bellow:  ./files/5ingress/ingress_install.sh\rOutput\nStarting Nginx Ingress Install\rCloning into \u0026#39;kubernetes-ingress\u0026#39;...\rremote: Enumerating objects: 1270, done.\rremote: Counting objects: 100% (1270/1270), done.\rremote: Compressing objects: 100% (799/799), done.\rremote: Total 34666 (delta 552), reused 1008 (delta 422), pack-reused 33396\rReceiving objects: 100% (34666/34666), 46.90 MiB | 9.88 MiB/s, done.\rResolving deltas: 100% (18747/18747), done.\rUpdating files: 100% (782/782), done.\rUpdating files: 100% (3425/3425), done.\rNote: switching to \u0026#39;v1.10.1\u0026#39;.\rYou are in \u0026#39;detached HEAD\u0026#39; state. You can look around, make experimental\rchanges and commit them, and you can discard any commits you make in this\rstate without impacting any branches by switching back to a branch.\rIf you want to create a new branch to retain commits you create, you may\rdo so (now or later) by using -c with the switch command. Example:\rgit switch -c \u0026lt;new-branch-name\u0026gt;\rOr undo this operation with:\rgit switch -\rTurn off this advice by setting config variable advice.detachedHead to false\rHEAD is now at ba03a73d Release 1.10.1 (#1461)\rnamespace/nginx-ingress created\rserviceaccount/nginx-ingress created\rclusterrole.rbac.authorization.k8s.io/nginx-ingress created\rclusterrolebinding.rbac.authorization.k8s.io/nginx-ingress created\rclusterrole.rbac.authorization.k8s.io/nginx-ingress-app-protect created\rclusterrolebinding.rbac.authorization.k8s.io/nginx-ingress-app-protect created\rsecret/default-server-secret created\rconfigmap/nginx-config created\ringressclass.networking.k8s.io/nginx created\rcustomresourcedefinition.apiextensions.k8s.io/virtualservers.k8s.nginx.org created\rcustomresourcedefinition.apiextensions.k8s.io/virtualserverroutes.k8s.nginx.org created\rcustomresourcedefinition.apiextensions.k8s.io/transportservers.k8s.nginx.org created\rcustomresourcedefinition.apiextensions.k8s.io/policies.k8s.nginx.org created\rcustomresourcedefinition.apiextensions.k8s.io/globalconfigurations.k8s.nginx.org created\rglobalconfiguration.k8s.nginx.org/nginx-configuration created\rcustomresourcedefinition.apiextensions.k8s.io/aplogconfs.appprotect.f5.com created\rcustomresourcedefinition.apiextensions.k8s.io/appolicies.appprotect.f5.com created\rcustomresourcedefinition.apiextensions.k8s.io/apusersigs.appprotect.f5.com created\rservice/nginx-ingress created\rdeployment.apps/nginx-ingress created\rconfigmap/nginx-config configured\rInstall finished\r Expose the Nginx Ingress Dashboard.  cat \u0026lt;\u0026lt; EOF | kubectl apply -f -\rapiVersion: v1\rkind: Service\rmetadata:\rname: dashboard-nginx-ingress\rnamespace: nginx-ingress\rannotations:\rservice.beta.kubernetes.io/aws-load-balancer-backend-protocol: \u0026quot;tcp\u0026quot;\rservice.beta.kubernetes.io/aws-load-balancer-type: nlb\rspec:\rtype: LoadBalancer\rports:\r- port: 80\rtargetPort: 8080\rprotocol: TCP\rname: http\rselector:\rapp: nginx-ingress\rEOF\rCheck what we did so far is actually working:  kubectl get svc --namespace=nginx-ingress\rOutput\nNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE\rdashboard-nginx-ingress LoadBalancer 172.20.36.60 aeb592ad4011544219c0bc49581baa13-421891138.eu-central-1.elb.amazonaws.com 80:32044/TCP 11m\rnginx-ingress LoadBalancer 172.20.14.206 ab21b88fec1f445d98c79398abc2cd5d-961716132.eu-central-1.elb.amazonaws.com 80:30284/TCP,443:31110/TCP 5h35m\r Note the EXTERNAL-IP of the \u0026ldquo;dashboard-nginx-ingress\u0026rdquo;. This is the hostname that we are going to use in order to view the Nginx Dashboard.\nBrowse to the following location and verify you can see the dashboard: http://\u0026lt;DASHBOARD-EXTERNAL-IP\u0026gt;/dashboard.html\nNote the EXTERNAL-IP of the \u0026ldquo;nginx-ingress\u0026rdquo;. This is the hostname that we are going to use in order to publish the Arcadia web application.\nBrowse to the following location and verify that you receive a 404 status code: http://\u0026lt;INGRESS-EXTERNAL-IP\u0026gt;/\nPlease note that it might take some time for the DNS names to become available.\n\rSave the EXTERNAL-IPs as env variables for later use  export dashboard_nginx_ingress=$(kubectl get svc dashboard-nginx-ingress --namespace=nginx-ingress | tr -s \u0026quot; \u0026quot; | cut -d' ' -f4 | grep -v \u0026quot;EXTERNAL-IP\u0026quot;)\rexport nginx_ingress=$(kubectl get svc nginx-ingress --namespace=nginx-ingress | tr -s \u0026quot; \u0026quot; | cut -d' ' -f4 | grep -v \u0026quot;EXTERNAL-IP\u0026quot;)\r"
},
{
	"uri": "/070_cleanup/010_cleanup/",
	"title": "Remove configuration",
	"tags": [],
	"description": "",
	"content": " In order to delete the resources created during this workshop, run the commands below:  kubectl delete --all svc --namespace=nginx-ingress\rkubectl delete --all svc --namespace=default\rcd terraform\rterraform destroy --auto-approve\r Finally, delete the previously created Cloud9 stack in the CloudFormation console.  \rPlease note: This will also delete the Cloud9 IDE instance.\n\r"
},
{
	"uri": "/050_service_mesh/010_mesh_explanation_1/",
	"title": "Service Mesh Overview",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/020_terraform/010_terraform_apply_1/",
	"title": "Terraform Apply",
	"tags": [],
	"description": "",
	"content": " Go to the \u0026ldquo;terraform\u0026rdquo; directory where we can find the terraform plan.  cd terraform Run the following commands, terraform plan will show us what it is going to be deployed in AWS by Terraform:  terraform init terraform plan Now let\u0026rsquo;s deploy the environment  terraform apply --auto-approve \rIt will take around 10 minutes for Terraform and AWS to finish the initial deployment.\nPlease continue to the next page to learn about Kubernetes and Amazon EKS basics.\n\r"
},
{
	"uri": "/060_security/010_waf_deployment/",
	"title": "Waf deployment",
	"tags": [],
	"description": "",
	"content": " Create the Nginx WAF config, which can be found in the \u0026ldquo;files/7waf/waf-config.yaml\u0026rdquo; file.  kubectl apply -f files/7waf/waf-config.yaml\rThe WAF policy is json based and from the example bellow, you can observe how all the configuration can be changed based on the application needs:\n{\r\u0026quot;name\u0026quot;: \u0026quot;nginx-policy\u0026quot;,\r\u0026quot;template\u0026quot;: { \u0026quot;name\u0026quot;: \u0026quot;POLICY_TEMPLATE_NGINX_BASE\u0026quot; },\r\u0026quot;applicationLanguage\u0026quot;: \u0026quot;utf-8\u0026quot;,\r\u0026quot;enforcementMode\u0026quot;: \u0026quot;blocking\u0026quot;,\r\u0026quot;signature-sets\u0026quot;: [\r{\r\u0026quot;name\u0026quot;: \u0026quot;All Signatures\u0026quot;,\r\u0026quot;block\u0026quot;: false,\r\u0026quot;alarm\u0026quot;: true\r},\r{\r\u0026quot;name\u0026quot;: \u0026quot;High Accuracy Signatures\u0026quot;,\r\u0026quot;block\u0026quot;: true,\r\u0026quot;alarm\u0026quot;: true\r}\r],\r\u0026quot;blocking-settings\u0026quot;: {\r\u0026quot;violations\u0026quot;: [\r{\r\u0026quot;name\u0026quot;: \u0026quot;VIOL_RATING_NEED_EXAMINATION\u0026quot;,\r\u0026quot;alarm\u0026quot;: true,\r\u0026quot;block\u0026quot;: true\r},\r{\r\u0026quot;name\u0026quot;: \u0026quot;VIOL_HTTP_PROTOCOL\u0026quot;,\r\u0026quot;alarm\u0026quot;: true,\r\u0026quot;block\u0026quot;: true,\r\u0026quot;learn\u0026quot;: true\r},\r{\r\u0026quot;name\u0026quot;: \u0026quot;VIOL_FILETYPE\u0026quot;,\r\u0026quot;alarm\u0026quot;: true,\r\u0026quot;block\u0026quot;: true,\r\u0026quot;learn\u0026quot;: true\r},\r{\r\u0026quot;name\u0026quot;: \u0026quot;VIOL_COOKIE_MALFORMED\u0026quot;,\r\u0026quot;alarm\u0026quot;: true,\r\u0026quot;block\u0026quot;: false,\r\u0026quot;learn\u0026quot;: false\r}\r],\r\u0026quot;http-protocols\u0026quot;: [{\r\u0026quot;description\u0026quot;: \u0026quot;Body in GET or HEAD requests\u0026quot;,\r\u0026quot;enabled\u0026quot;: true,\r\u0026quot;learn\u0026quot;: true,\r\u0026quot;maxHeaders\u0026quot;: 20,\r\u0026quot;maxParams\u0026quot;: 500\r}],\r\u0026quot;filetypes\u0026quot;: [\r{\r\u0026quot;name\u0026quot;: \u0026quot;*\u0026quot;,\r\u0026quot;type\u0026quot;: \u0026quot;wildcard\u0026quot;,\r\u0026quot;allowed\u0026quot;: true,\r\u0026quot;responseCheck\u0026quot;: true\r}\r],\r\u0026quot;data-guard\u0026quot;: {\r\u0026quot;enabled\u0026quot;: true,\r\u0026quot;maskData\u0026quot;: true,\r\u0026quot;creditCardNumbers\u0026quot;: true,\r\u0026quot;usSocialSecurityNumbers\u0026quot;: true\r},\r\u0026quot;cookies\u0026quot;: [\r{\r\u0026quot;name\u0026quot;: \u0026quot;*\u0026quot;,\r\u0026quot;type\u0026quot;: \u0026quot;wildcard\u0026quot;,\r\u0026quot;accessibleOnlyThroughTheHttpProtocol\u0026quot;: true,\r\u0026quot;attackSignaturesCheck\u0026quot;: true,\r\u0026quot;insertSameSiteAttribute\u0026quot;: \u0026quot;strict\u0026quot;\r}\r],\r\u0026quot;evasions\u0026quot;: [{\r\u0026quot;description\u0026quot;: \u0026quot;%u decoding\u0026quot;,\r\u0026quot;enabled\u0026quot;: true,\r\u0026quot;learn\u0026quot;: false,\r\u0026quot;maxDecodingPasses\u0026quot;: 2\r}]}\r}\rDeploy ELK in order to be able to visualize and analyze the traffic going through the Nginx WAF  kubectl apply -f files/7waf/elk.yaml\rIn order to connect to our ELK pod, we will need to find the public address of this service:  kubectl get svc elk-web\rOutput\nNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE\relk-web LoadBalancer 172.20.179.34 a28bd2d8c94214ae0b512274daa06211-2103709514.eu-central-1.elb.amazonaws.com 5601:32471/TCP,9200:32589/TCP,5044:31876/TCP 16h\r 4. Verify that ELK is up and running by browsing to: http://[ELK-EXTERNAL-IP]:5601/.\nPlease note that it might take some time for the DNS name to become available.\n\rNext, we need to change our deployment configuration so it includes the Nginx WAF  kubectl apply -f files/7waf/arcadia-main.yaml\rkubectl apply -f files/7waf/arcadia-app2.yaml\rkubectl apply -f files/7waf/arcadia-app3.yaml\rkubectl apply -f files/7waf/arcadia-backend.yaml\rAll of our services are protected and monitored.\n"
},
{
	"uri": "/010_intro/",
	"title": "Intro to the workshop",
	"tags": [],
	"description": "",
	"content": "Intro to the workshop\nThis workshop will provide guidelines on how to deploy an application from scratch in Amazon Elastic Kubernetes Service environment while protecting and enhancing the application availability and usability with Nginx solutions.\nFor this workshop we are going to use the \u0026ldquo;Arcadia Financial\u0026rdquo; application. The application is built with 4 different microservices that are deployed in the Kubernetes environment.\n Main - provides access to the web GUI of the application for use by browsers Backend - is a supporting microservice and provides support for the customer facing services only App2 - provides money transfer API based functionalities for both the Web app and third party consumer applications App3 - provides referral API based functionalities for both the Web app and third party consumer applications  By the end of the workshop the \u0026ldquo;Arcadia Financial\u0026rdquo; will be fully deployed and protected as described in the bellow diagram.\n"
},
{
	"uri": "/020_terraform/020_eks_1/",
	"title": "AWS EKS",
	"tags": [],
	"description": "",
	"content": "While you wait, you can review the Introduction section of the AWS EKS Workshop to learn about Kubernetes and Amazon EKS basics.\nManaged control plane Amazon EKS provides a scalable and highly-available control plane that runs across multiple AWS availability zones. The Amazon EKS service automatically manages the availability and scalability of the Kubernetes API servers and the etcd persistence layer for each cluster. Amazon EKS runs the Kubernetes control plane across three Availability Zones in order to ensure high availability, and it automatically detects and replaces unhealthy masters.\nManaged worker nodes Amazon EKS lets you create, update, or terminate worker nodes for your cluster with a single command. Managed node groups run nodes using the latest EKS-optimized AMIs in your AWS account while updates and terminations gracefully drain nodes to ensure your applications stay available.\n"
},
{
	"uri": "/010_intro/selfpaced/020_cloudformation_1/",
	"title": "Cloud Formation",
	"tags": [],
	"description": "",
	"content": " Click the bellow button and deploy the template:  \n Click Next and enter a unique \u0026ldquo;Stack name\u0026rdquo;\n  Click Next 2 times accepting all the defaults, but make sure the following is selected on the last screen:\n  Click Create stack.  Wait until the stack Status is CREATE_COMPLETE.\n"
},
{
	"uri": "/020_terraform/",
	"title": "Deploy NGINX infrastructure using Terraform",
	"tags": [],
	"description": "",
	"content": "Deploy NGINX infrastructure using Terraform\nWe will start by using Terraform to deploy the initial infrastructure which includes the Amazon Elastic Kubernetes Service and the EC2 instance for the Nginx Controller.\n"
},
{
	"uri": "/060_controller/020_microgateway/",
	"title": "Microgateway deployment",
	"tags": [],
	"description": "",
	"content": " Deploy the microgateway with the following configuration.  cat \u0026lt;\u0026lt; EOF | kubectl apply -f -\rapiVersion: apps/v1\rkind: Deployment\rmetadata:\rname: microgateway\rspec:\rreplicas: 1\rselector:\rmatchLabels:\rapp: microgateway\rtemplate:\rmetadata:\rlabels:\rapp: microgateway\rspec:\rcontainers:\r- name: microgateway1\rimage: sorinboia/ngtest:3.4\rimagePullPolicy: Always\renv:\r- name: API_KEY\rvalue: $controller_apikey\r- name: CTRL_HOST\rvalue: $controller_ip\r- name: HOSTNAME\rvalue: microgateway1 ports:\r- containerPort: 80\rreadinessProbe:\rexec:\rcommand:\r- curl\r- 127.0.0.1:49151/api\rinitialDelaySeconds: 5\rperiodSeconds: 5\r---\rapiVersion: v1\rkind: Service\rmetadata:\rname: microgateway\rannotations: service.beta.kubernetes.io/aws-load-balancer-type: \u0026quot;nlb\u0026quot;\rservice.beta.kubernetes.io/aws-load-balancer-backend-protocol: \u0026quot;tcp\u0026quot;\rspec:\rselector:\rapp: microgateway\rports:\r- port: 80\rtargetPort: 80\rname: http\r- port: 443\rtargetPort: 443\rname: https type: LoadBalancer\rEOF\rFrom now on we will only use the Controller GUI do to all of our configuration.\nThe end goal will be to expose and protect our APIs both internally within the cluster and externally to other programmers.\nLogin to the Nginx Controller web UI, click the \u0026ldquo;N\u0026rdquo; button in the upper left corner and go to \u0026ldquo;Infrastructure\u0026rdquo; -\u0026gt; \u0026ldquo;Instances\u0026rdquo;.  You will see the microgateway we just deployed listed. If it is not there wait for about 2 minutes, it might take a little bit of time for the instance to register.\nGet the EXTERNAL-IP of the microgateway service we just published, we will use it later within our config.  export microhost=$(kubectl get svc microgateway | tr -s \u0026quot; \u0026quot; | cut -d' ' -f4 | grep -v \u0026quot;EXTERNAL-IP\u0026quot;) \u0026amp;\u0026amp; echo $microhost\rOutput\naa2ba08e2b4024a85ba93aa32d0bafac-603500592.eu-central-1.elb.amazonaws.com\r "
},
{
	"uri": "/050_service_mesh/020_nsm_deploy/",
	"title": "Nginx Service Mesh deployment",
	"tags": [],
	"description": "",
	"content": " Deploy all Nginx components in the Kubernetes environment  nginx-meshctl deploy --registry-server \u0026quot;sorinboia\u0026quot; --image-tag 0.9.0 --sample-rate 1 --disable-auto-inject\rOutput\nDeploying NGINX Service Mesh Control Plane in namespace \u0026#34;nginx-mesh\u0026#34;...\rCreated namespace \u0026#34;nginx-mesh\u0026#34;.\rCreated SpiffeID CRD.\rWaiting for SPIRE to be running...done.\rDeployed Spire.\rDeployed NATS server.\rCreated traffic policy CRDs.\rDeployed Mesh API.\rDeployed Metrics API Server.\rDeployed Prometheus Server nginx-mesh/prometheus.\rDeployed Grafana nginx-mesh/grafana.\rDeployed tracing server nginx-mesh/zipkin.\rAll resources created. Testing the connection to the Service Mesh API Server...\rConnected to the NGINX Service Mesh API successfully.\rVerifying that all images were pulled...done.\rNGINX Service Mesh is running.\r All components have been deployed in the \u0026ldquo;nginx-mesh\u0026rdquo; namespace, run the following command and validate that all pods are running  kubectl get pods -n nginx-mesh\rOutput\ngrafana-766d495d65-mjngv 1/1 Running 0 5m30s\rnats-server-7d457c74d9-csjt2 1/1 Running 0 5m34s\rnginx-mesh-api-575858b96b-djq7h 1/1 Running 0 5m32s\rnginx-mesh-metrics-57dd4796b8-6mtqc 1/1 Running 0 5m31s\rprometheus-67dc46b8b6-2wkgg 1/1 Running 0 5m30s\rspire-agent-nv5z2 1/1 Running 0 6m18s\rspire-server-0 2/2 Running 0 6m18s\rzipkin-564b9d4954-4hqdr 1/1 Running 0 5m29s\r "
},
{
	"uri": "/040_ingress/020_ingress_01/",
	"title": "Publish the app",
	"tags": [],
	"description": "",
	"content": "Expose all the application services and route traffic based on the HTTP path. We will start with a basic configuration.\n Expose Arcadia to the world.  cat \u0026lt;\u0026lt; EOF | kubectl apply -f -\rapiVersion: k8s.nginx.org/v1\rkind: VirtualServer\rmetadata:\rname: arcadia\rspec:\rhost: $nginx_ingress upstreams:\r- name: arcadia-users\rservice: arcadia-users\rport: 80\r- name: arcadia-login\rservice: arcadia-login\rport: 80\r- name: arcadia-stocks\rservice: arcadia-stocks\rport: 80\r- name: arcadia-stock-transaction\rservice: arcadia-stock-transaction\rport: 80\r- name: arcadia-frontend\rservice: arcadia-frontend\rport: 80\rroutes:\r- path: /v1/user action:\rpass: arcadia-users\r- path: /v1/login action:\rpass: arcadia-login\r- path: /v1/stock action:\rpass: arcadia-stocks\r- path: /v1/stockt action:\rpass: arcadia-stock-transaction\r- path: / action:\rpass: arcadia-frontend\rEOF\rNote how the various HTTP paths (/, /api/, /app3/) are routed by Ingress to the relevant K8s services.\nAt this stage the basic install is finished and all that\u0026rsquo;s left is to check the connectivity to the Arcadia web application. Get the public hostname of the exposed nginx-ingress service.\n Browse to the following location and verify that you can access the site: http://\u0026lt;INGRESS-EXTERNAL-IP\u0026gt;/\n  Login to the application using the following credentials:\n  Username: trader@gmail.com\nPassword: 123456\n\rAt the moment we still have two key features missing:\n We are serving only http, not https. We want our site to be fully secured therefore all communications need to be encrypted We are not actively monitoring the health of the pods through the data path   Take a look at the files/5ingress/2arcadia.yaml file. It increases the number of pods for our services to two - and also defines how the http health checks will looks like.\n  Apply this new configuration.\n  kubectl apply -f files/5ingress/1arcadia_increase.yaml\rLook at the Nginx dashboard and click on \u0026ldquo;HTTP Upstreams\u0026rdquo;, you can see that right now that two HTTP upstreams have 2 members but no health checks are being done.  "
},
{
	"uri": "/060_security/020_testing/",
	"title": "Testing the Waf",
	"tags": [],
	"description": "",
	"content": "  Browse again to the Arcadia web app and verify that it is still working.\n  Let\u0026rsquo;s simulate a Cross Site Scripting (XSS) attack, and make sure it\u0026rsquo;s blocked:\n  https://\u0026lt;INGRESS-EXTERNAL-IP\u0026gt;/trading/index.php?a=%3Cscript%3Ealert(%27xss%27)%3C/script%3E\nEach of the blocked requests will generate a support ID, save it for later.\nBrowse to the ELK as before and click the \u0026ldquo;Discover\u0026rdquo; button:  Here, you\u0026rsquo;ll see all the request logs, allowed and blocked, sent by the Nginx WAF to ELK.\nLet\u0026rsquo;s look for the reason why our attack requests were blocked.\nAdd a filter with the support ID you have received as seen bellow:  In the right side of the panel, you can see the full request log and the reason why it was blocked.\nContinue and explore the visualization capabilities of Kibana and log information from Nginx WAF by looking into the next two sections bellow the \u0026ldquo;Discover\u0026rdquo; button (Visualize and Dashboard -\u0026gt; Overview).  "
},
{
	"uri": "/060_controller/030_configuration/",
	"title": "Build the configuration",
	"tags": [],
	"description": "",
	"content": " Create an environment  \u0026ldquo;N\u0026rdquo; -\u0026gt; \u0026ldquo;Services\u0026rdquo; -\u0026gt; \u0026ldquo;Environments\u0026rdquo; -\u0026gt; \u0026ldquo;Create Environment\u0026rdquo; In all the fields, enter the following value: prod.\nClick on \u0026ldquo;View API Request\u0026rdquo;.\nAll the configuration on the Nginx Controller can be easlly automated with external orchestration systems, this view can help you in understanding how to generate the configuration API calls.\nThe output will look like this: Output\n{\r\u0026#34;metadata\u0026#34;: {\r\u0026#34;name\u0026#34;: \u0026#34;prod\u0026#34;,\r\u0026#34;displayName\u0026#34;: \u0026#34;prod\u0026#34;,\r\u0026#34;description\u0026#34;: \u0026#34;prod\u0026#34;,\r\u0026#34;tags\u0026#34;: [\r\u0026#34;prod\u0026#34;\r]\r},\r\u0026#34;desiredState\u0026#34;: {}\r}\r\nClick \u0026ldquo;Submit\u0026rdquo;.\nCreate the Certificate:  \u0026ldquo;N\u0026rdquo; -\u0026gt; \u0026ldquo;Services\u0026rdquo; -\u0026gt; \u0026ldquo;Certs\u0026rdquo; -\u0026gt; \u0026ldquo;Create Cert\u0026rdquo;  Name: server-cert\nEnvironment: prod \nChose \u0026ldquo;Copy and paste PEM text\u0026rdquo;\nPrivate Key: Browse to https://raw.githubusercontent.com/sorinboia/nginx-experience-aws/master/certs_for_mtls/ca.key copy and paste.\nPublic Cert: Browse to https://raw.githubusercontent.com/sorinboia/nginx-experience-aws/master/certs_for_mtls/ca.pem copy and paste.\nSubmit\n Create the Gateway:  \u0026ldquo;N\u0026rdquo; -\u0026gt; \u0026ldquo;Services\u0026rdquo; -\u0026gt; \u0026ldquo;Gateways\u0026rdquo; -\u0026gt; \u0026ldquo;Create Gateway\u0026rdquo;  Name: api.arcadia.aws.cloud\nEnvironment: prod\nInstance Refs: Select All\nHostname: https://\u0026lt;EXTERNAL-IP OF THE \u0026quot;microgateway\u0026quot; SERVICE\u0026gt;\nCert Reference: server-cert\nSubmit\n Create the App:  \u0026ldquo;N\u0026rdquo; -\u0026gt; \u0026ldquo;Services\u0026rdquo; -\u0026gt; \u0026ldquo;Apps\u0026rdquo; -\u0026gt; \u0026ldquo;Create App\u0026rdquo;  Name: arcadia-api\nEnvironment: prod\nSubmit\n So far we have created an environment, uploaded the certificate/key that we will use for our HTTPS connection, created a gateway which represents our entry point into the API gateway and last defined a new application object.\n"
},
{
	"uri": "/030_application/",
	"title": "Deploy The Arcadia Crypto application",
	"tags": [],
	"description": "",
	"content": "We will deploy our application in the Kubernetes environment.\nAs stated before these are the 4 microservices which we will deploy.\n Main - provides access to the web GUI of the application for use by browsers Backend - is a supporting microservice and provides support for the customer facing services only App2 - provides money transfer API based functionalities for both the Web app and third party consumer applications App3 - provides referral API based functionalities for both the Web app and third party consumer applications  "
},
{
	"uri": "/020_terraform/030_eks_verification_1/",
	"title": "EKS Verification",
	"tags": [],
	"description": "",
	"content": "Wait for Terraform to finish and verify the deployment is working as expected and we are able to control the Kubernetes environment.\n We need to save the remote access config for the Kubernetes cluster locally:  mkdir ~/.kube/ terraform output \u0026gt; ~/.kube/config\rCheck and see that our cluster is up an running.\nBelow we should see our two K8s worker nodes:  kubectl get nodes\rOutput\nNAME STATUS ROLES AGE VERSION ip-10-0-2-32.eu-central-1.compute.internal Ready none 84s v1.15.10-eks-bac369 ip-10-0-3-217.eu-central-1.compute.internal Ready none 88s v1.15.10-eks-bac369  And the kube-system pods (this is the namespace for objects created by the Kubernetes system):\nAt the moment we have our setup deployed as it can be seen in the bellow diagram.\nChange the directory back to the original repo folder:  cd ..\r"
},
{
	"uri": "/040_ingress/030_health_https_1/",
	"title": "Enable https and monitoring",
	"tags": [],
	"description": "",
	"content": "In our next step we will finish this part of the configuration, we will implement the following:\n Enable health checks Enable https for the application and redirect http requests to https   Apply the configuration.  cat \u0026lt;\u0026lt; EOF | kubectl apply -f -\rapiVersion: v1\rdata:\rtls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUZMRENDQkJTZ0F3SUJBZ0lTQTUrVmpoQmN3NUJKNWk0QXU2VGl0L3h0TUEwR0NTcUdTSWIzRFFFQkN3VUEKTURJeEN6QUpCZ05WQkFZVEFsVlRNUll3RkFZRFZRUUtFdzFNWlhRbmN5QkZibU55ZVhCME1Rc3dDUVlEVlFRRApFd0pTTXpBZUZ3MHlNVEF4TVRjeE1USXpNek5hRncweU1UQTBNVGN4TVRJek16TmFNQjR4SERBYUJnTlZCQU1NCkV5b3VZWEpqWVdScFlXTnllWEIwYnk1dVpYUXdnZ0VpTUEwR0NTcUdTSWIzRFFFQkFRVUFBNElCRHdBd2dnRUsKQW9JQkFRRE1LQkNYWHdaL0xQbzNmM2pMR3IvamhNRXNTZmdrT3ErOGtOUEpxVzdPbGtCazRrZWtlaEtFVVVDQwowUHdUazgrbnp0Skg3bzBEOUNaaEZuVW9pSGVnZkRzTURFNWFoVXh4blQ1czlmWHZvRlJqSnlYUUR0VlhvR1VQCk1ubzJlVkdYYi81Qm1LeVNJMDVpQ3B5SCtNVC9YRHFhd3BhV2ZsTDJ5OXpZK1V2NGlkQVhsZFpDUnBVSEhOV1cKZjhPeUMvcFJiZndhYVYzRDJ6RjFaeHJ6Z2JIcWd3WXpkRHNnYXVkdk56N0pocytDaENxL1JQNWhMSGNkNzV5bQo1bmppTFZsVmcvYUZJS09IT2wyZ1RFdnQ4WWdjTXdUSWgwNjRrcWpVS3g5UDBmQkpZSzNwV0ZoelhwaENHaWd1CjdTd3EyYnpGTkZabjY1SEdtSDBJY1RLMVlNSm5BZ01CQUFHamdnSk9NSUlDU2pBT0JnTlZIUThCQWY4RUJBTUMKQmFBd0hRWURWUjBsQkJZd0ZBWUlLd1lCQlFVSEF3RUdDQ3NHQVFVRkJ3TUNNQXdHQTFVZEV3RUIvd1FDTUFBdwpIUVlEVlIwT0JCWUVGSXhRMk9EMjhFWjVaVkNTRmNBTlVLbEdqcTFVTUI4R0ExVWRJd1FZTUJhQUZCUXVzeGUzCldGYkxybEFKUU9ZZnI1MkxGTUxHTUZVR0NDc0dBUVVGQndFQkJFa3dSekFoQmdnckJnRUZCUWN3QVlZVmFIUjAKY0RvdkwzSXpMbTh1YkdWdVkzSXViM0puTUNJR0NDc0dBUVVGQnpBQ2hoWm9kSFJ3T2k4dmNqTXVhUzVzWlc1agpjaTV2Y21jdk1CNEdBMVVkRVFRWE1CV0NFeW91WVhKallXUnBZV055ZVhCMGJ5NXVaWFF3VEFZRFZSMGdCRVV3ClF6QUlCZ1puZ1F3QkFnRXdOd1lMS3dZQkJBR0MzeE1CQVFFd0tEQW1CZ2dyQmdFRkJRY0NBUllhYUhSMGNEb3YKTDJOd2N5NXNaWFJ6Wlc1amNubHdkQzV2Y21jd2dnRUVCZ29yQmdFRUFkWjVBZ1FDQklIMUJJSHlBUEFBZHdCRQpsR1V1c083T3I4UkFCOWlvL2lqQTJ1YUN2dGpMTWJVLzB6T1d0YmFCcUFBQUFYY1FUTzdSQUFBRUF3QklNRVlDCklRQ3hMK0hhdnVOY1kzRU0yNllwN0JEeTA1TW8yTUxreHYrdE5nMHA0QmRVQlFJaEFOT1dIWmR1Z056UHl4MEkKOU5VWHVOL09JaGlnS2RGMjhlMmM0TWV3dVRmVEFIVUE5bHlVTDlGM01DSVVWQmdJTUpSV2p1Tk5FeGt6djk4TQpMeUFMekU3eFpPTUFBQUYzRUV6d3V3QUFCQU1BUmpCRUFpQWwvNEZaL1ZwR1NRV3pwdUc2Q0ljWUdHOG4wM1ZZCmRTQnFxUlFHbWUxdnVnSWdRMXg3cnRqYXhrcDNRd3FweWhYRXJyWjhPN3lIdTF2di9pdFhWR1haZzBjd0RRWUoKS29aSWh2Y05BUUVMQlFBRGdnRUJBSnh0Zmk1NmxxZ1RFUEJ6NE82R2xZclJYOVlnL3Y5cUMwWE1DazFSWlJWRApuRldQcTBQUFRWeWR3UTRsOVZQMWhlaTZhNUY0R2xQOVFzaFk3TS9CRFA0SmgwR3pOYnBCY2h4Slc2MHBuUXEzCjI4WmovNzVhamVycTFxYnEvbXpIZHhGcGVzTkVON3NYbUpzNGsrM1pOeWs3N1lXRVhsb1BDMk9STGM2MmhWWlAKdk1sYXZycmNmYWFGNTYvZkR3QzdRd2JZa3JHQzEycFZ4STMzNlFQSGJrRVE2SDNhWGUweE9Dem4rUnZxdXRMTwpqNjh2UVExWG5LdktLc0dCTVNGM29QaGYxZHZtbi9pZHBtK1RjdFJ3ZmUzTGtrL2JpZEJ2a2pJam5jb05HR1pTCllLSFVybmRzMWpDclRVTnI0RFgwTlY5bFNVOG5jUzdMMFBFOGxuUXYrWjg9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0KLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUVaVENDQTAyZ0F3SUJBZ0lRUUFGMUJJTVVwTWdoaklTcERCYk4zekFOQmdrcWhraUc5dzBCQVFzRkFEQS8KTVNRd0lnWURWUVFLRXh0RWFXZHBkR0ZzSUZOcFoyNWhkSFZ5WlNCVWNuVnpkQ0JEYnk0eEZ6QVZCZ05WQkFNVApEa1JUVkNCU2IyOTBJRU5CSUZnek1CNFhEVEl3TVRBd056RTVNakUwTUZvWERUSXhNRGt5T1RFNU1qRTBNRm93Ck1qRUxNQWtHQTFVRUJoTUNWVk14RmpBVUJnTlZCQW9URFV4bGRDZHpJRVZ1WTNKNWNIUXhDekFKQmdOVkJBTVQKQWxJek1JSUJJakFOQmdrcWhraUc5dzBCQVFFRkFBT0NBUThBTUlJQkNnS0NBUUVBdXdJVktNejJvSlRURHhMcwpqVldTdy9pQzhabW1la0tJcDEwbXFyVXJ1Y1ZNc2ErT2EvbDF5S1BYRDBlVUZGVTFWNHllcUtJNUdmV0NQRUtwClRtNzFPOE11MjQzQXNGenpXVGpuN2M5cDhGb0xHNzdBbENRbGgvbzNjYk1UNXh5czRadnYyK1E3UlZKRmxxbkIKVTg0MHlGTHV0YTd0ajk1Z2NPS2xWS3UyYlE2WHBVQTBheXZUdkdiclpqUjgrbXVMajFjcG1mZ3dGMTI2Y20vNwpnY1d0MG9aWVBSZkg1d203OFN2M2h0ekIybkZkMUVianpLMGx3WWk4WUdkMVpyUHhHUGVpWE9aVC96cUl0a2VsCi94TVk2cGdKZHorZFUvblBBZVgxcG5BWEZLOWpwUCtaczVPZDNGT25CdjVJaFIyaGFhNGxkYnNUekZJRDllMVIKb1l2YkZRSURBUUFCbzRJQmFEQ0NBV1F3RWdZRFZSMFRBUUgvQkFnd0JnRUIvd0lCQURBT0JnTlZIUThCQWY4RQpCQU1DQVlZd1N3WUlLd1lCQlFVSEFRRUVQekE5TURzR0NDc0dBUVVGQnpBQ2hpOW9kSFJ3T2k4dllYQndjeTVwClpHVnVkSEoxYzNRdVkyOXRMM0p2YjNSekwyUnpkSEp2YjNSallYZ3pMbkEzWXpBZkJnTlZIU01FR0RBV2dCVEUKcDdHa2V5eHgrdHZoUzVCMS84UVZZSVdKRURCVUJnTlZIU0FFVFRCTE1BZ0dCbWVCREFFQ0FUQS9CZ3NyQmdFRQpBWUxmRXdFQkFUQXdNQzRHQ0NzR0FRVUZCd0lCRmlKb2RIUndPaTh2WTNCekxuSnZiM1F0ZURFdWJHVjBjMlZ1ClkzSjVjSFF1YjNKbk1Ed0dBMVVkSHdRMU1ETXdNYUF2b0MyR0syaDBkSEE2THk5amNtd3VhV1JsYm5SeWRYTjAKTG1OdmJTOUVVMVJTVDA5VVEwRllNME5TVEM1amNtd3dIUVlEVlIwT0JCWUVGQlF1c3hlM1dGYkxybEFKUU9ZZgpyNTJMRk1MR01CMEdBMVVkSlFRV01CUUdDQ3NHQVFVRkJ3TUJCZ2dyQmdFRkJRY0RBakFOQmdrcWhraUc5dzBCCkFRc0ZBQU9DQVFFQTJVemd5ZldFaURjeDI3c1Q0clA4aTJ0aUVteFl0MGwrUEFLM3FCOG9ZZXZPNEM1ejcwa0gKZWpXRUh4MnRhUERZL2xhQkwyMS9XS1p1TlRZUUhIUEQ1YjF0WGdIWGJuTDdLcUM0MDFkazVWdkNhZFRRc3ZkOApTOE1Yam9oeWM5ejkvRzI5NDhrTGptRTZGbGg5ZERZclZZQTl4Mk8raEVQR09hRU9hMWVlUHluQmdQYXl2VWZMCnFqQnN0ekxoV1ZRTEdBa1hYbU5zKzVablBCeHpESk9MeGhGMkpJYmVRQWNINUgwdFpyVWxvNVpZeU9xQTdzOXAKTzViODVvM0FNL09KK0NrdEZCUXRmdkJoY0pWZDl3dmx3UHNrK3V5T3kySEk3bU54S0tnc0JUdDM3NXRlQTJUdwpVZEhraFZOY3NBS1gxSDdHTk5MT0VBRGtzZDg2d3VvWHZnPT0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=\rtls.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV2UUlCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQktjd2dnU2pBZ0VBQW9JQkFRRE1LQkNYWHdaL0xQbzMKZjNqTEdyL2poTUVzU2Zna09xKzhrTlBKcVc3T2xrQms0a2VrZWhLRVVVQ0MwUHdUazgrbnp0Skg3bzBEOUNaaApGblVvaUhlZ2ZEc01ERTVhaFV4eG5UNXM5Zlh2b0ZSakp5WFFEdFZYb0dVUE1ubzJlVkdYYi81Qm1LeVNJMDVpCkNweUgrTVQvWERxYXdwYVdmbEwyeTl6WStVdjRpZEFYbGRaQ1JwVUhITldXZjhPeUMvcFJiZndhYVYzRDJ6RjEKWnhyemdiSHFnd1l6ZERzZ2F1ZHZOejdKaHMrQ2hDcS9SUDVoTEhjZDc1eW01bmppTFZsVmcvYUZJS09IT2wyZwpURXZ0OFlnY013VEloMDY0a3FqVUt4OVAwZkJKWUszcFdGaHpYcGhDR2lndTdTd3EyYnpGTkZabjY1SEdtSDBJCmNUSzFZTUpuQWdNQkFBRUNnZ0VCQUxlRm1JeUtWb3ZDUWRmYjFoazJIYU1IOXFLNmg3OEJwbkpxK29lQXNPUXkKdXdZMVIxTzZqS1MzYWJkdTUvc3RWM0V4QVdTNk03ZUhKVzBIUkNCQXRORG1mQ256Y2dmN1plR0lDZExuTThMSwpMTEhKUWp1SzZndFFXeWhUSnZ1TENXYUp2VlQ0U3NFL3pibGljcDNrYWlwbm5TTDdvMlQ3ZjlidEljVkdMUjNvCklhNU1SWnZ3ZDRHZzBkakErNUIwNWhXU3lDT3k0OHJFVzVKMUdCdC90eTBlaHhEOVVUVS9nb0ViL1Q1TXY1OVYKMWY2elNjS0lHbTh3emx5UnVZbWZwTkwrYjFkdFVUb1NUdVA5R0loU3FWTFN1NUJpR2RTMk81MFhqOWVUQlFhRgpRZUtrN002dWdjanZtZHdzTW4vdHM1T2pvVjY0bk10QlNWemY1VWhJdm1rQ2dZRUE2aGQwZWFHK3J1TFhKTDQwCncreUVuUDZtTktYQkI3eVNTWkVtck1aOWxGVUFxOVdQUk9pZnQ5Tm1vc1BGWi9QMDNBcWFhb3cxTGJmdjBMMFQKQ0hyNkJZSGhtYkNVTjJ6TExrRjZSVnI4NUhtQUxjdVhyajVEM3pZd3lZVmVJOThzV0RZcGVsaWtnOUFnNUFtagpNc3ZBTnRYRElJQmlXTkFQQzJoWXhORisrTHNDZ1lFQTMwTm15ZDFzSi9UaFJvUFpoK2dMNmZ0S2RySE1EWk1zCjRHZkI5K2FDTDNtR3NwU094MTlHOHJmbG9ZU2xNTE5HdnlZcGo1SGg1aHJnQXc4aGVBS3BFRmxFVTdBcm54dVcKZmwwc2J3RkhwN05pZUZscGFPdzU2Mm9FN3c1M2pPRHBIQ1ZLSFphQ0lHZjVLSS9tQmRuVWZYZ1JzSzExdjZMTwpJaExYMFNSM3FFVUNnWUFscUpaTlJ1NzFGWHNFNXpCMzRHSEpHOUpESC9NNHVtWlNQVzZhVnVnMjU2SFBBdkVrClpjUGovN2RBTWZ4YzU4c1padjlHYXIzWFdBTFZjc1ZRRlBDSjJFWWh3bDFsdVRQS2dqQVlYalhXejVFR1RQMWUKdzVlSm5oOGxIRFp6ME9CQ1pKd3htWGNGMllLaERNZmJVUm5mK0cyR21nQzRSdWhVcm5teFYvNTBKd0tCZ0RmSAo2VWlLTDltVHp5MEZDRFp5ZlhlS04wS01qWVRldnBtYWt0WFRHN2VzejBDUzZWRmF0cWt4MVFlVDBvbm1ZTWlsClNrRDZtOHdYN3R3VXpiSGtTRVV6YUdUWVlTMnhnTm8xZ1VLQ3VWcG04VFZNY1krclpaVXh1ZVhZWVhvclAxS3UKNW1PYUZRenZyVXE3R1NkaEV6djk0YjJZdVJDV0pwWlF5dWNRQzIxWkFvR0FKbnNGeHl4ZmFXajFEVHUxcEttNQpTSHQvL0cyRGZteHhKQ05aTFZMUHJYVDJhWmdrNWQwMW5Zb3dydCtscCtiSXBLc09BS2MxamxtRVNwT2VaTEU1Cmk0UVV0eEs3SnV5dHNNZXdqUCtYdmc3VFNEN3d1bW95Vkh6RS9VOTBYcldPOVJJd1VlZFpmOFg4bjVPNCtaRisKeWpqaWNlcGY1ci9DaFNhZG1jM1RwMFk9Ci0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0K\rkind: Secret\rmetadata:\rname: arcadia-wildcard\rtype: kubernetes.io/tls\r---\rapiVersion: k8s.nginx.org/v1\rkind: VirtualServer\rmetadata:\rname: arcadia\rspec:\rhost: $nginx_ingress tls:\rsecret: arcadia-wildcard # Represents the server certificate\rredirect:\renable: true # Always redirect to https if incoming request is http\rupstreams:\r- name: arcadia-users\rservice: arcadia-users\rport: 80\rhealthCheck: # This is the most basic healthcheck config for more info follow this link https://docs.nginx.com/nginx-ingress-controller/configuration/virtualserver-and-virtualserverroute-resources/#upstream-healthcheck\renable: true\rpath: /healthz\r- name: arcadia-login\rservice: arcadia-login\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\r- name: arcadia-stocks\rservice: arcadia-stocks\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\r- name: arcadia-stock-transaction\rservice: arcadia-stock-transaction\rport: 80\rhealthCheck: enable: true\rpath: /healthz\r- name: arcadia-frontend\rservice: arcadia-frontend\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\rroutes:\r- path: /v1/user action:\rpass: arcadia-users\r- path: /v1/login action:\rpass: arcadia-login\r- path: /v1/stock action:\rpass: arcadia-stocks\r- path: /v1/stockt action:\rpass: arcadia-stock-transaction\r- path: / action:\rpass: arcadia-frontend\rEOF\rBrowse to the Arcadia website with http and you will be automatically redirected to https.\nLook at the Nginx dashboard and observe that Nginx has started monitoring the pods.  "
},
{
	"uri": "/010_intro/selfpaced/030_iam_role_1/",
	"title": "IAM Role",
	"tags": [],
	"description": "",
	"content": "  Follow this deep link to find your Cloud9 EC2 instance\n  Select the instance, then choose Actions / Instance Settings / Attach/Replace IAM Role\n  Choose eksworkshop-admin from the IAM Role drop down, and select Apply  "
},
{
	"uri": "/050_service_mesh/030_side_car_injection/",
	"title": "Side Car Injection",
	"tags": [],
	"description": "",
	"content": " Inject the sidecar into the application pods  kubectl get deployment arcadia-frontend -oyaml | nsm inject | kubectl apply -f -\rkubectl get deployment arcadia-login -oyaml | nsm inject | kubectl apply -f -\rkubectl get deployment arcadia-stock-transaction -oyaml | nsm inject | kubectl apply -f -\rkubectl get deployment arcadia-stocks -oyaml | nsm inject | kubectl apply -f -\rkubectl get deployment arcadia-users -oyaml | nsm inject | kubectl apply -f -\r"
},
{
	"uri": "/040_ingress/040_oidc_1/",
	"title": "Authentication with Openid Connect and Okta",
	"tags": [],
	"description": "",
	"content": " Redeploy the front and microservice to a new version in order to use Openid.  cat \u0026lt;\u0026lt; EOF | kubectl apply -f -\rapiVersion: apps/v1\rkind: Deployment\rmetadata:\rname: arcadia-frontend\rspec:\rreplicas: 2\rselector:\rmatchLabels:\rapp: arcadia-frontend\rtemplate:\rmetadata:\rlabels:\rapp: arcadia-frontend\rspec:\rcontainers:\r- name: arcadia-frontend\rimage: sorinboia/arcadia-frontend:oktav0.1\rimagePullPolicy: Always\rports:\r- containerPort: 80\rEOF\rNext we need to configure our Ingress controller to validate each request based on the JWT token and if valid add a custom header which indicates to the application the user.  cat \u0026lt;\u0026lt; EOF | kubectl apply -f -\r# This secret contains the public json web keys needed to validate the token apiVersion: v1\rkind: Secret\rmetadata:\rname: jwk-secret\rtype: nginx.org/jwk\rdata:\rjwk: eyJrZXlzIjpbeyJrdHkiOiJSU0EiLCJhbGciOiJSUzI1NiIsImtpZCI6IlJKSEtrSWFBbkcwaGFWU3pqTWd6RHFlWEh4ajdkdUpfS0xkYUxxTnU3WUkiLCJ1c2UiOiJzaWciLCJlIjoiQVFBQiIsIm4iOiJoZ3hHTjJxM2RlQzZGcXBweTFySzRjMW5wX1JnMDBDMnpIVUlNdGlBbnJVc1VaVnlENWJjdHhybGF6dzF6ZTBHVkhYUkVCOXJyTnN0ZFJGM1NTU2VIajBjMGw4NE01ZWNqSHlBMzl5UnMtUkVtejdmeTRUWXBBeUpXakg0d0RmbTFfV2pvM1VUS3BiNGRDZ0xLU1RhRy1fUmVFOEl0Q0VhM0lLa1hZdTFtQ1h5QWFGVDYwaWoxV3Y3TUJGWnpKUmYxV0hSOEp6eDhhd2Roc0JlZ1lGR2J6Q0Z0V0prYUVNU2tDV1piRTJSOTkzWV9qc1dLRVJiWlpyM2pkRElMX0txNkJ6S3RDYXJDckMwbHB2SDdnUFVDSXlYUWNpUE9ZY2NxaXQ2R3NBLThlRnpjSkk2dkpRM3VvRXA5ZDJGSmVTUmFrSnNMZDNhcS1odVh5N3ZjZ1k2MHcifV19\r---\r# Nginx Policy which will be be used in the Virtual Server to perform the JWT validation\rapiVersion: k8s.nginx.org/v1\rkind: Policy\rmetadata:\rname: jwt-policy\rspec:\rjwt:\rrealm: apis\rsecret: jwk-secret\r---\rapiVersion: k8s.nginx.org/v1\rkind: VirtualServer\rmetadata:\rname: arcadia\rspec:\rhost: $nginx_ingress tls:\rsecret: arcadia-wildcard # Represents the server certificate\rredirect:\renable: true # Always redirect to https if incoming request is http\rupstreams:\r- name: arcadia-users\rservice: arcadia-users\rport: 80\rhealthCheck: # This is the most basic healthcheck config for more info follow this link https://docs.nginx.com/nginx-ingress-controller/configuration/virtualserver-and-virtualserverroute-resources/#upstream-healthcheck\renable: true\rpath: /healthz\r- name: arcadia-login\rservice: arcadia-login\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\r- name: arcadia-stocks\rservice: arcadia-stocks\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\r- name: arcadia-stock-transaction\rservice: arcadia-stock-transaction\rport: 80\rhealthCheck: enable: true\rpath: /healthz\r- name: arcadia-frontend\rservice: arcadia-frontend\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\rroutes:\r- path: /v1/user # These directives attach the JWT policy to the route that needs authentication extract the username/email address and add it as a header policies:\r- name: jwt-policy\raction:\rproxy:\rupstream: arcadia-users\rrequestHeaders:\rset:\r- name: okta-user\rvalue: \\${jwt_claim_email}\r- path: /v1/login action:\rpass: arcadia-login\r- path: /v1/stock action:\rpass: arcadia-stocks\r- path: /v1/stockt policies:\r- name: jwt-policy\raction:\rproxy:\rupstream: arcadia-stock-transaction\rrequestHeaders:\rset:\r- name: okta-user\rvalue: \\${jwt_claim_email}\r- path: / action:\rpass: arcadia-frontend\rEOF\rNext we need to register the application end points to the Openid Connect provider  curl http://okta.arcadiacrypto.net:8080/okta-update?domain=$nginx_ingress\r"
},
{
	"uri": "/010_intro/040_cloud9_1/",
	"title": "Cloud 9",
	"tags": [],
	"description": "",
	"content": " Open the Cloud9 console, and click on Open IDE. This will open a cloud-based integrated development environment (IDE) that lets you write, run, and debug your code with just a browser. It includes a code editor, debugger, and a terminal. We will be using it for the rest of the workshop.  \rAd blockers, javascript disablers, and tracking blockers should be disabled for the cloud9 domain, or connecting to the workspace might be impacted. Cloud9 requires third-party-cookies. You can whitelist the specific domains.\n\rRun the following command to install all the software tools required to run the workshop:  labs/eks/install.sh\rThe output of the script should show: Output\nkubectl in path\rjq in path\renvsubst in path\raws in path\raws-iam-authenticator in path\rterraform in path\r\n Disable temporary credentials:   In the Cloud9 IDE click the gear icon (in top right corner), or click to open a new tab and choose \u0026ldquo;Open Preferences\u0026rdquo; Select AWS SETTINGS Turn off AWS managed temporary credentials Close the Preferences tab    Validate the IAM role:  Use the GetCallerIdentity CLI command to validate that the Cloud9 IDE is using the correct IAM role.\naws sts get-caller-identity --query Arn | grep eksworkshop-admin -q \u0026amp;\u0026amp; echo \u0026quot;IAM role valid\u0026quot; || echo \u0026quot;IAM role NOT valid\u0026quot;\rIf the IAM role is not valid, DO NOT PROCEED. Go back and confirm the steps on this page.\n Clone the Workshop Repo:  git https://github.com/sorinboia/nginx-experience-aws-ac2.0.git\rcd nginx-experience-aws-ac2.0/\r "
},
{
	"uri": "/060_controller/040_apis/",
	"title": "Import the OpenApi definition",
	"tags": [],
	"description": "",
	"content": "Next we are going to publish the application APIs to the world.\nThere are two ways of creating this configuration, the first one is manual similar to the way we performed the configuration until this point and the second one is described bellow.\nAs part of their development cycle, the developers of the Arcadia application are generating an OpenApi specification to describe their APIs.\nWe are going to use this API specification in order to publish the services to the world.\n Run the following curl commands.  curl -k -sc cookie.txt -X POST --url \u0026quot;https://$controller_ip/api/v1/platform/login\u0026quot; --header 'Content-Type: application/json' --data '{\u0026quot;credentials\u0026quot;: {\u0026quot;type\u0026quot;: \u0026quot;BASIC\u0026quot;,\u0026quot;username\u0026quot;: \u0026quot;nginx@f5.com\u0026quot;,\u0026quot;password\u0026quot;: \u0026quot;Admin2020\u0026quot;}}' curl -k -sb cookie.txt -c cookie.txt --location --request PUT \u0026quot;https://$controller_ip/api/v1/services/api-definitions/arcadia-api/versions/v1\u0026quot; --header 'Content-Type: application/json' --header 'Content-Type: text/plain' --data \u0026quot;@files/6controller/arcadia_api_spec.json\u0026quot;\rWe have just uploaded the OpenApi spec to the Nginx Controller.\n Go to \u0026ldquo;N\u0026rdquo; -\u0026gt; \u0026ldquo;Services\u0026rdquo; -\u0026gt; \u0026ldquo;APIs\u0026rdquo;.\nYou can see the \u0026ldquo;Arcadia API\u0026rdquo; definition listed.\n  Check the DNS name of the backend servers we need to point our APIs to:\n  kubectl get svc\rOutput\nNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE\rarcadia-app2 ClusterIP 172.20.103.189 none 80/TCP 171m\rarcadia-app3 ClusterIP 172.20.238.13 none 80/TCP 171m\rarcadia-backend ClusterIP 172.20.228.83 none 80/TCP 109m\rarcadia-main ClusterIP 172.20.166.2 none 80/TCP 7s\rbackend ClusterIP 172.20.44.133 none 80/TCP 171m\rkubernetes ClusterIP 172.20.0.1 none 443/TCP 8h\rmicrogateway LoadBalancer 172.20.81.110 a2fa7314165114fb9b16ebd92a890078-367878391.eu-central-1.elb.amazonaws.com 80:32293/TCP,443:32428/TCP 12m\r We are interested in \u0026ldquo;main\u0026rdquo; and \u0026ldquo;app2\u0026rdquo; and their DNS names are arcadia-main and arcadia-app2.\n"
},
{
	"uri": "/040_ingress/",
	"title": "Increase availability, security and application performance with Kubernetes Nginx Ingress",
	"tags": [],
	"description": "",
	"content": "Previously we have deployed the application but did not expose the services.\nWe need to be able to route the requests to the relevant service.\nNginx Kubernetes Ingress to save the day! :) The NGINX Ingress Controller for Kubernetes provides enterprise‑grade delivery services for Kubernetes applications, with benefits for users of both NGINX Open Source and NGINX Plus. With the NGINX Ingress Controller for Kubernetes, you get basic load balancing, SSL/TLS termination, support for URI rewrites, and upstream SSL/TLS encryption. NGINX Plus users additionally get session persistence for stateful applications and JSON Web Token (JWT) authentication for APIs.\n"
},
{
	"uri": "/050_service_mesh/040_opentracing/",
	"title": "Service Mesh Visibility",
	"tags": [],
	"description": "",
	"content": "In order to be able and trace and monitor all of our application calls we will need to expose the Grafana and Zipkin servers\n Expose Grapha and Zipkin  kubectl get svc -n nginx-mesh grafana -oyaml | sed 's/ClusterIP/LoadBalancer/g' | kubectl apply -f -\rkubectl get svc -n nginx-mesh zipkin -oyaml | sed 's/ClusterIP/LoadBalancer/g' | kubectl apply -f -\rGet the svc external ip  kubectl get svc grafana zipkin -n nginx-mesh\rOutput\nNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE\rgrafana LoadBalancer 172.20.176.7 a85065a76e142478fb29cdd2f2904e82-320541984.eu-central-1.elb.amazonaws.com 3000:31309/TCP 4d23h\rzipkin LoadBalancer 172.20.88.44 a7c02ef8a39b74da4ad41085261859f8-765188493.eu-central-1.elb.amazonaws.com 9411:31661/TCP 4d23h\r Browse to the Grafana dashboard http://\u0026lt;GRAFANA-EXTERNAL-IP\u0026gt;:3000  You can get a general look for you application status. The Grafana dashboards can be customized to your hearts desire.\n Go and buy or sell crypto coin. We will use Zipkin to trace this operation through the different services.   Browse to the Zipkin dashboard http://\u0026lt;ZIPKIN-EXTERNAL-IP\u0026gt;:9411 Create a filter as in the bellow image. Click on the result that looks like the first entry.   Explanation of what is going on\n  "
},
{
	"uri": "/050_service_mesh/050_mesh_acl/",
	"title": "Mesh Access List",
	"tags": [],
	"description": "",
	"content": "The Kubernetes networking environment by default is an open network without restrictions or limitations.\nThis means that any pod can access any other pod or service. This introduces potential risks.\nOur arcadia-users exposes an internal API /v1/user_i/ which is used by the arcadia-login service only. This means that no other service should have access to it. Lets see what security implications this has:\n Access the arcadia-stocks pod. This pod is used only to get current crypto prices and nothing else. It should not be able to contact any other pod.  export arcadia_stocks_pod=$(kubectl get pods --selector=app=arcadia-stocks | grep arcadia-stocks -m 1 | cut -d' ' -f1)\rwinpty kubectl exec -it $arcadia_stocks_pod -- bash\rOutput\nDefaulting container name to arcadia-stocks.\rUse \u0026#39;kubectl describe pod/arcadia-stocks-7bd6ff78c8-pb6bn -n default\u0026#39; to see all of the containers in this pod.\rroot@arcadia-stocks-7bd6ff78c8-pb6bn:/usr/src/app#\r You are now in the arcadia-stocks container, the bellow command will access the arcadia-users internal API and get specific user information.\nThis should not be allowed. This call must be allowed only from the arcadia-login pods.  curl http://arcadia-users/v1/user_i/c29yaW5AbmdpbnguY29t\rOutput\n{\u0026#34;_id\u0026#34;:\u0026#34;6072b09ce6915d87d36e66af\u0026#34;,\u0026#34;accountId\u0026#34;:\u0026#34;47808892\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;Sorin Boiangiu\u0026#34;,\u0026#34;email\u0026#34;:\u0026#34;sorin@nginx.com\u0026#34;,\u0026#34;cash\u0026#34;:121973.826,\u0026#34;password\u0026#34;:\u0026#34;nginx\u0026#34;,\u0026#34;stocks\u0026#34;:{\u0026#34;btc\u0026#34;:1.1989999999999994,\u0026#34;eth\u0026#34;:3.5,\u0026#34;ltc\u0026#34;:40.1},\u0026#34;picture\u0026#34;:\u0026#34;default\u0026#34;}\r Improve you application security by introducing these checks and allowing access only from the arcadia-login pods  cat \u0026lt;\u0026lt; EOF | kubectl apply -f -\rapiVersion: v1\rkind: ServiceAccount\rmetadata:\rname: arcadia-users-sa\r---\rapiVersion: v1\rkind: ServiceAccount\rmetadata:\rname: arcadia-login-sa\r---\rapiVersion: specs.smi-spec.io/v1alpha3\rkind: HTTPRouteGroup\rmetadata:\rname: route-group\rspec:\rmatches:\r- name: destination-traffic\rmethods:\r- GET\r---\rapiVersion: access.smi-spec.io/v1alpha2\rkind: TrafficTarget\rmetadata:\rname: traffic-target\rspec:\rdestination:\rkind: ServiceAccount\rname: arcadia-users-sa\rrules:\r- kind: HTTPRouteGroup\rname: route-group\rmatches:\r- destination-traffic\rsources:\r- kind: ServiceAccount\rname: arcadia-login-sa\rEOF\rAttach the service account to the pods  kubectl set serviceaccount deployments/arcadia-users arcadia-users-sa\rkubectl set serviceaccount deployments/arcadia-login arcadia-login-sa\rAccess the arcadia-stocks pod and retry getting user information from the arcadia-users service, this time it will be blocked.  export arcadia_stocks_pod=$(kubectl get pods --selector=app=arcadia-stocks | grep arcadia-stocks -m 1 | cut -d' ' -f1)\rwinpty kubectl exec -it $arcadia_stocks_pod -- bash\rcurl http://arcadia-users/v1/user_i/c29yaW5AbmdpbnguY29t\rOutput\n\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;403 Forbidden\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;center\u0026gt;\u0026lt;h1\u0026gt;403 Forbidden\u0026lt;/h1\u0026gt;\u0026lt;/center\u0026gt;\r\u0026lt;hr\u0026gt;\u0026lt;center\u0026gt;nginx/1.19.5\u0026lt;/center\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r Access the arcadia-login pod and try getting user information from the arcadia-users service, only this service should be allowed.  export arcadia_login_pod=$(kubectl get pods --selector=app=arcadia-login | grep arcadia-login -m 1 | cut -d' ' -f1)\rwinpty kubectl exec -it $arcadia_login_pod -- bash\rcurl http://arcadia-users/v1/user_i/c29yaW5AbmdpbnguY29t\rOutput\n{\u0026#34;_id\u0026#34;:\u0026#34;6072b09ce6915d87d36e66af\u0026#34;,\u0026#34;accountId\u0026#34;:\u0026#34;47808892\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;Sorin Boiangiu\u0026#34;,\u0026#34;email\u0026#34;:\u0026#34;sorin@nginx.com\u0026#34;,\u0026#34;cash\u0026#34;:121973.826,\u0026#34;password\u0026#34;:\u0026#34;nginx\u0026#34;,\u0026#34;stocks\u0026#34;:{\u0026#34;btc\u0026#34;:1.1989999999999994,\u0026#34;eth\u0026#34;:3.5,\u0026#34;ltc\u0026#34;:40.1},\u0026#34;picture\u0026#34;:\u0026#34;default\u0026#34;}\r "
},
{
	"uri": "/040_ingress/060_mtls_1/",
	"title": "Mutual TLS",
	"tags": [],
	"description": "",
	"content": "Enabling MTLS on our Nginx Ingress Controller is quite simple.\n Create the Certificate Secret and a policy to use on the Virtual Server resource  cat \u0026lt;\u0026lt; EOF | kubectl apply -f -\rkind: Secret\rmetadata:\rname: ingress-mtls-secret\rapiVersion: v1\rtype: nginx.org/ca\rdata:\rca.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUQvVENDQXVXZ0F3SUJBZ0lVSzdhbU14OFlLWG1BVG51SkZETDlWS2ZUR2ZNd0RRWUpLb1pJaHZjTkFRRUwKQlFBd2dZMHhDekFKQmdOVkJBWVRBbFZUTVFzd0NRWURWUVFJREFKRFFURVdNQlFHQTFVRUJ3d05VMkZ1SUVaeQpZVzVqYVhOamJ6RU9NQXdHQTFVRUNnd0ZUa2RKVGxneEREQUtCZ05WQkFzTUEwdEpRekVXTUJRR0ExVUVBd3dOCmEybGpMbTVuYVc1NExtTnZiVEVqTUNFR0NTcUdTSWIzRFFFSkFSWVVhM1ZpWlhKdVpYUmxjMEJ1WjJsdWVDNWoKYjIwd0hoY05NakF3T1RFNE1qQXlOVEkyV2hjTk16QXdPVEUyTWpBeU5USTJXakNCalRFTE1Ba0dBMVVFQmhNQwpWVk14Q3pBSkJnTlZCQWdNQWtOQk1SWXdGQVlEVlFRSERBMVRZVzRnUm5KaGJtTnBjMk52TVE0d0RBWURWUVFLCkRBVk9SMGxPV0RFTU1Bb0dBMVVFQ3d3RFMwbERNUll3RkFZRFZRUUREQTFyYVdNdWJtZHBibmd1WTI5dE1TTXcKSVFZSktvWklodmNOQVFrQkZoUnJkV0psY201bGRHVnpRRzVuYVc1NExtTnZiVENDQVNJd0RRWUpLb1pJaHZjTgpBUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBTmFINVRzaTZzaUFsU085dEJnYmY3VVRwcWowMUhRTlQ2UjhtQy9pCjhLYXFaSW9XSUdvN2xhTW9xTDYydTc4ay9WOHM2Z0FJaU1DSzBjekFvTFhNSnlJQkxQeTg4Yzdtc2xwZXgxTkEKVmRtMkVTVkN6bVlERE1TT3FpVmszWmpYeC9URmo2QzhNRFhhRkZUWFg1dWdtbWdscnFCWlh0OVI5VVBwVTJMNwo1bEZ0NlJ2R3VGczgvbVZORVR5c1A0SFhCWlh2ZE9mdG1YWUkvK01hOW5CMzIzNjdmcTI0L0RKZ2YvK2xRbUsxCkJLR3poSTZSc1pSSmdWOXdpK1VuZTBYNjlaS2lLOFdXU3lZS252YnRrcHZuTDA2dGNJaXJZNi80UzZ4Sm1HRVQKZEJUNmVxc0NoSUpQUStWSEp5dTROdnV6WmVCUXpGdmMwNytnUGZkVWZra1FXODhDQXdFQUFhTlRNRkV3SFFZRApWUjBPQkJZRUZKUGdhcnFYa00rdEJ0djVhdndTUWhUQmpTU2VNQjhHQTFVZEl3UVlNQmFBRkpQZ2FycVhrTSt0CkJ0djVhdndTUWhUQmpTU2VNQThHQTFVZEV3RUIvd1FGTUFNQkFmOHdEUVlKS29aSWh2Y05BUUVMQlFBRGdnRUIKQUl3WXpoY0s4OWtRL0xGWjZFRHgrQWp2bnJTVSs1cmdwQkgrRjVTNUUyY3pXOE5rNXhySnl0Y0ZUbUtlKzZScwpENHlxeTZSVVFEeWNYaDlPelBjbzgzYTBoeFlCZ1M5MWtJa25wYWF4dndLRDJleWc3UGNnK1lkS1FhZFlMcUY0CmI3cWVtc1FVVkpOWHdkZS9VanRBejlEOTh4dngwM2hQY2Qwb2dzUUhWZ21BZVpFd2l3UzFmTy9WNUE4dTl3MEkKcHlJRTVReXlHcHNpS2dpalpiMmhrS05RVHVJcEhiVnFydVA4eEV6TlFnamhkdS9uUW5OYy9lRUltVUlrQkFUVQpiSHdQc2xwYzVhdVV1TXJxR3lEQ0p2QUJpV3J2SmE3Yi9XcmtDT3FUWVhtR2NGM0w1ZU9FeTBhYkp0M2NNcSs5CnJLTUNVQWlkNG0yNEthWnc3OUk2anNBPQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==\r---\rapiVersion: k8s.nginx.org/v1\rkind: Policy\rmetadata:\rname: ingress-mtls-policy\rspec:\ringressMTLS:\rclientCertSecret: ingress-mtls-secret\rverifyClient: \u0026quot;on\u0026quot;\rverifyDepth: 1\rEOF\rAttach the MTLS policy to the VS.  cat \u0026lt;\u0026lt; EOF | kubectl apply -f -\rapiVersion: k8s.nginx.org/v1\rkind: VirtualServer\rmetadata:\rname: arcadia\rspec:\rhost: $nginx_ingress tls:\rsecret: arcadia-wildcard # Represents the server certificate\rredirect:\renable: true # Always redirect to https if incoming request is http\rpolicies:\r- name: ingress-mtls-policy\rupstreams:\r- name: arcadia-users\rservice: arcadia-users\rport: 80\rhealthCheck: # This is the most basic healthcheck config for more info follow this link https://docs.nginx.com/nginx-ingress-controller/configuration/virtualserver-and-virtualserverroute-resources/#upstream-healthcheck\renable: true\rpath: /healthz\r- name: arcadia-login\rservice: arcadia-login\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\r- name: arcadia-stocks\rservice: arcadia-stocks\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\r- name: arcadia-stock-transaction\rservice: arcadia-stock-transaction\rport: 80\rhealthCheck: enable: true\rpath: /healthz\r- name: arcadia-frontend\rservice: arcadia-frontend\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\rroutes:\r- path: /v1/user # These directives attach the JWT policy to the route that needs authentication extract the username/email address and add it as a header policies:\r- name: jwt-policy\raction:\rproxy:\rupstream: arcadia-users\rrequestHeaders:\rset:\r- name: okta-user\rvalue: \\${jwt_claim_email}\r- path: /v1/login action:\rpass: arcadia-login\r- path: /v1/stock action:\rpass: arcadia-stocks\r- path: /v1/stockt policies:\r- name: jwt-policy\raction:\rproxy:\rupstream: arcadia-stock-transaction\rrequestHeaders:\rset:\r- name: okta-user\rvalue: \\${jwt_claim_email}\r- path: / action:\rpass: arcadia-frontend\rEOF\rVerify this is actually working by running the bellow command, it will use the client cert/key pair on the Cloud9 instance to authenticate:  curl -k https://$nginx_ingress/ --cert ./files/5ingress/client-cert.pem --key ./files/5ingress/client-key.pem\rWe are finished with this part of our experience and achieved the bellow environment.\nBefore moving forward reapply the ingress configuration without the two lines we just added.  cat \u0026lt;\u0026lt; EOF | kubectl apply -f -\rapiVersion: k8s.nginx.org/v1\rkind: VirtualServer\rmetadata:\rname: arcadia\rspec:\rhost: $nginx_ingress tls:\rsecret: arcadia-wildcard # Represents the server certificate\rredirect:\renable: true # Always redirect to https if incoming request is http\rupstreams:\r- name: arcadia-users\rservice: arcadia-users\rport: 80\rhealthCheck: # This is the most basic healthcheck config for more info follow this link https://docs.nginx.com/nginx-ingress-controller/configuration/virtualserver-and-virtualserverroute-resources/#upstream-healthcheck\renable: true\rpath: /healthz\r- name: arcadia-login\rservice: arcadia-login\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\r- name: arcadia-stocks\rservice: arcadia-stocks\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\r- name: arcadia-stock-transaction\rservice: arcadia-stock-transaction\rport: 80\rhealthCheck: enable: true\rpath: /healthz\r- name: arcadia-frontend\rservice: arcadia-frontend\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\rroutes:\r- path: /v1/user # These directives attach the JWT policy to the route that needs authentication extract the username/email address and add it as a header policies:\r- name: jwt-policy\raction:\rproxy:\rupstream: arcadia-users\rrequestHeaders:\rset:\r- name: okta-user\rvalue: \\${jwt_claim_email}\r- path: /v1/login action:\rpass: arcadia-login\r- path: /v1/stock action:\rpass: arcadia-stocks\r- path: /v1/stockt policies:\r- name: jwt-policy\raction:\rproxy:\rupstream: arcadia-stock-transaction\rrequestHeaders:\rset:\r- name: okta-user\rvalue: \\${jwt_claim_email}\r- path: / action:\rpass: arcadia-frontend\rEOF\r"
},
{
	"uri": "/050_service_mesh/",
	"title": "Nginx Service Mesh",
	"tags": [],
	"description": "",
	"content": "Service Mesh\n"
},
{
	"uri": "/060_controller/050_publish_apis/",
	"title": "Publish the external APIs",
	"tags": [],
	"description": "",
	"content": "We are now going to publish the previously imported OpenApi definition.\n Publish the APIs:  \u0026ldquo;N\u0026rdquo; -\u0026gt; \u0026ldquo;Services\u0026rdquo; -\u0026gt; \u0026ldquo;APIs\u0026rdquo; -\u0026gt; Click \u0026ldquo;arcadia-api\u0026rdquo; -\u0026gt; Click \u0026ldquo;Add Published API\u0026rdquo; Fill in the data as described bellow   Name: arcadia-published-api\nClick Next\n  Environment: prod\nApp: arcadia-api\nGateways: api.arcadia.aws.cloud\nClick Next\n We will now add the components that represent the workload for the main app that traffic will be sent to.\nClick \u0026ldquo;Add New\u0026rdquo; on the \u0026ldquo;Components\u0026rdquo; column and fill the data as described bellow   Name: arcadia-main-component\nClick Next\n  Workload Group Name: arcadia-main-wl\nURI: http://arcadia-main\nClick Submit\n Add the second component that represents the workload for app2\nClick \u0026ldquo;Add New\u0026rdquo; on the \u0026ldquo;Components\u0026rdquo; column and fill the data as described bellow   Name: arcadia-app2-component\nClick Next\n  Workload Group Name: arcadia-app2-wl\nURI: http://arcadia-app2 Click Submit\n Move the routes that start with \u0026ldquo;/api\u0026rdquo; in the \u0026ldquo;Unrouted\u0026rdquo; to the \u0026ldquo;Components\u0026rdquo; column under the \u0026ldquo;arcadia-app2-component\u0026rdquo;. Move the remaining routes under \u0026ldquo;arcadia-main-component\u0026rdquo; and click Submit  We have finished publishing the API all is left is to test it. Run the bellow curl command, you should receive a success message and if you go to the main Arcadia application and refresh the page you will be able to see the transaction we just did in the \u0026ldquo;Transfer History\u0026rdquo; section.  curl -k --location --request POST https://$microhost/api/rest/execute_money_transfer.php --header 'Content-Type: application/json' --data-raw '{\u0026quot;amount\u0026quot;:\u0026quot;77\u0026quot;,\u0026quot;account\u0026quot;:\u0026quot;2075894\u0026quot;,\u0026quot;currency\u0026quot;:\u0026quot;EUR\u0026quot;,\u0026quot;friend\u0026quot;:\u0026quot;Alfredo\u0026quot;}'\rOutput\n{\u0026#34;name\u0026#34;:\u0026#34;Alfredo\u0026#34;, \u0026#34;status\u0026#34;:\u0026#34;success\u0026#34;,\u0026#34;amount\u0026#34;:\u0026#34;77\u0026#34;, \u0026#34;currency\u0026#34;:\u0026#34;EUR\u0026#34;, \u0026#34;transid\u0026#34;:\u0026#34;944962065\u0026#34;, \u0026#34;msg\u0026#34;:\u0026#34;The money transfer has been successfully completed \u0026#34;}\r "
},
{
	"uri": "/060_controller/060_add_auth/",
	"title": "Add authentication to the API",
	"tags": [],
	"description": "",
	"content": "Our APIs are published and now we will want to add authentication based on API Keys\n Create an Identity Provider:  \u0026ldquo;N\u0026rdquo; -\u0026gt; \u0026ldquo;Services\u0026rdquo; -\u0026gt; \u0026ldquo;Identity Provider\u0026rdquo; -\u0026gt; \u0026ldquo;Create an Identity Provider\u0026rdquo;  Name: api-protect\nEnvironment: prod\nType: API Key\n Under \u0026ldquo;API Clients\u0026rdquo;\n Name: test-client\nKey: 1234567890\nClick Submit\n Go the the edit mode of APIs we have previously published  \u0026ldquo;N\u0026rdquo; -\u0026gt; \u0026ldquo;Services\u0026rdquo; -\u0026gt; \u0026ldquo;APIs\u0026rdquo; -\u0026gt; Click \u0026ldquo;arcadia-api\u0026rdquo; -\u0026gt; Click the edit icon Attach the new Identity Provider to the APIs   Click \u0026ldquo;Routing\u0026rdquo;\nClick the edit icon of \u0026ldquo;arcadia-app2-component\u0026rdquo; component security setting\n Click \u0026ldquo;Add Authentication\u0026rdquo; and fill in the fields   Identity Provider: api-protect\nCredential Location: Header\nCredentials Value: apikey\nClick Done\nClick Submit\nClick Submit again on the \u0026ldquo;Edit Published API\u0026rdquo; page\n Check that the authentication is failing when not providing an API key  curl -k --location --request POST https://$microhost/api/rest/execute_money_transfer.php --header 'Content-Type: application/json' --data-raw '{\u0026quot;amount\u0026quot;:\u0026quot;77\u0026quot;,\u0026quot;account\u0026quot;:\u0026quot;2075894\u0026quot;,\u0026quot;currency\u0026quot;:\u0026quot;EUR\u0026quot;,\u0026quot;friend\u0026quot;:\u0026quot;Alfredo\u0026quot;}'\rOutput\n\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;401 Authorization Required\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;center\u0026gt;\u0026lt;h1\u0026gt;401 Authorization Required\u0026lt;/h1\u0026gt;\u0026lt;/center\u0026gt;\r\u0026lt;hr\u0026gt;\u0026lt;center\u0026gt;nginx\u0026lt;/center\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r Try again but this time including the API key and the test-client value  curl -k --location --request POST https://$microhost/api/rest/execute_money_transfer.php --header \u0026quot;apikey: 1234567890\u0026quot; --header 'Content-Type: application/json' --data-raw '{\u0026quot;amount\u0026quot;:\u0026quot;77\u0026quot;,\u0026quot;account\u0026quot;:\u0026quot;2075894\u0026quot;,\u0026quot;currency\u0026quot;:\u0026quot;EUR\u0026quot;,\u0026quot;friend\u0026quot;:\u0026quot;Alfredo\u0026quot;}'\rOutput\n{\u0026#34;name\u0026#34;:\u0026#34;Alfredo\u0026#34;, \u0026#34;status\u0026#34;:\u0026#34;success\u0026#34;,\u0026#34;amount\u0026#34;:\u0026#34;77\u0026#34;, \u0026#34;currency\u0026#34;:\u0026#34;EUR\u0026#34;, \u0026#34;transid\u0026#34;:\u0026#34;772067369\u0026#34;, \u0026#34;msg\u0026#34;:\u0026#34;The money transfer has been successfully completed \u0026#34;}\r "
},
{
	"uri": "/060_controller/",
	"title": "Nginx Controller",
	"tags": [],
	"description": "",
	"content": "We have finished the first part of the publishing our application, now we want to publish our APIs to be used by third party organizations. We will acomplish this using two components:\n Nginx Controller which will be used as an API Management Nginx Container will be the API Microgateway which will reside within the Kubernetes environment  "
},
{
	"uri": "/060_security/",
	"title": "Security",
	"tags": [],
	"description": "",
	"content": "In our final part of the workshop, we will implement a per-pod Web Application Firewall.\nThe Nginx WAF will allow to improve the application security posture, especially against OWASP Top 10 attacks.\nIn our scenario, since we decided our Nginx WAF to be enabled on a per-pod basis, we will be able to protect all the traffic coming into the pod regardless of where it is originating from (external or internal to the Kubernetes cluster).\nWe\u0026rsquo;ll be able to bring security closer to the application and the development cycle and integrate it into CI/CD pipelines.\nThis will allow to minimize false positives, since the WAF policy becomes a part of the application and is always tested as such.\n"
},
{
	"uri": "/070_cleanup/",
	"title": "Cleanup",
	"tags": [],
	"description": "",
	"content": "If you have run this workshop on your own environment you might need to delete the created resources. Please follow the steps in the next part.\n"
},
{
	"uri": "/080_feedback/",
	"title": "Feedback",
	"tags": [],
	"description": "",
	"content": "The code in this repo is under constant development.\nFor any feedback or suggestions, either open an Issue on GitHub, or contact:\nSorin for any NGINX related topics\nArtiom for any AWS related topics\n"
},
{
	"uri": "/060_controller/070_summary/",
	"title": "Summary",
	"tags": [],
	"description": "",
	"content": "All of our microgateway API configuration is complete. We have published external APIs and are able to route, authenticate and view statistics for traffic coming from API clients. We have achieved the bellow architecture:\n"
},
{
	"uri": "/050_service_mesh/060_external_acl/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/060_security/tmp/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "cat \u0026laquo; EOF | kubectl apply -f - apiVersion: appprotect.f5.com/v1beta1 kind: APPolicy metadata: name: attacksigs spec: policy: name: attacksigs template: name: POLICY_TEMPLATE_NGINX_BASE applicationLanguage: utf-8 enforcementMode: blocking signature-sets: - name: All Signatures block: true alarm: true\n apiVersion: appprotect.f5.com/v1beta1 kind: APLogConf metadata: name: logconf spec: content: format: default max_message_size: 64k max_request_size: any filter: request_type: all apiVersion: k8s.nginx.org/v1 kind: Policy metadata: name: waf-policy spec: waf: enable: true apPolicy: \u0026ldquo;default/attacksigs\u0026rdquo; securityLog: enable: true apLogConf: \u0026ldquo;default/logconf\u0026rdquo; logDest: \u0026ldquo;syslog:server=127.0.0.1:514\u0026rdquo;\nEOF\ncat \u0026laquo; EOF | kubectl apply -f - apiVersion: k8s.nginx.org/v1 kind: VirtualServer metadata: name: arcadia spec: host: $nginx_ingress\ntls: secret: arcadia-wildcard # Represents the server certificate redirect: enable: true # Always redirect to https if incoming request is http policies: - name: waf-policy upstreams: - name: arcadia-users service: arcadia-users port: 80 healthCheck: # This is the most basic healthcheck config for more info follow this link https://docs.nginx.com/nginx-ingress-controller/configuration/virtualserver-and-virtualserverroute-resources/#upstream-healthcheck enable: true path: /healthz - name: arcadia-login service: arcadia-login port: 80 healthCheck: enable: true path: /healthz - name: arcadia-stocks service: arcadia-stocks port: 80 healthCheck: enable: true path: /healthz - name: arcadia-stock-transaction service: arcadia-stock-transaction port: 80 healthCheck: enable: true path: /healthz - name: arcadia-frontend service: arcadia-frontend port: 80 healthCheck: enable: true path: /healthz routes: - path: /v1/user\nThese directives attach the JWT policy to the route that needs authentication extract the username/email address and add it as a header  policies:\r- name: jwt-policy\raction:\rproxy:\rupstream: arcadia-users\rrequestHeaders:\rset:\r- name: okta-user\rvalue: \\${jwt_claim_email}\r- path: /v1/login action:\rpass: arcadia-login\r- path: /v1/stock action:\rpass: arcadia-stocks\r- path: /v1/stockt policies:\r- name: jwt-policy\raction:\rproxy:\rupstream: arcadia-stock-transaction\rrequestHeaders:\rset:\r- name: okta-user\rvalue: \\${jwt_claim_email}\r- path: / action:\rpass: arcadia-frontend\r EOF\n"
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]