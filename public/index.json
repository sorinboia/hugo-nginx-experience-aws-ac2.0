[
{
	"uri": "/",
	"title": "Nginx Experience",
	"tags": [],
	"description": "",
	"content": "Welcome to AWS NGINX Meetup – From Application code to Customer Delivering modern applications has upped the needs to provide agile application services free from infrastructure constrains, while ensuring applications run faster, secured and at scale. Choosing the right architecture for application services allows organizations to innovate faster and role new services on any infrastructure or cloud architecture. From code development to customer consumption, NGINX deployed on AWS is helping millions of organizations deliver application infrastructure and services ensuring their application are fast, secure and run at scale.\nIntro to the workshop In this workshop you will experience how to deploy your application in an agile way, using NGINX utilizing AWS compute, applying all the application services needed, such as service mesh, API management and web application firewall in a fully automated way.\nDeploy NGINX infrastructure using Terraform Start by using automation and use Infrastructure as Code concepts to deploy the environment.\nIncrease availability, security and application performance with Kubernetes Nginx Ingress Monitor the application performance, discover issues and improve performance Authenticate users with OpenID Connect and offload authentication processes from the application to Nginx Zero Trust - Applying Mutual TLS authentication with NGINX Security Secure you application with Nginx App Protect Web Application Firewall.\nProtect you application from fraudulent interactions and separate legitimate traffic from unwanted one Block unwanted Bot traffic to your application "
},
{
	"uri": "/030_application/010_app_deployment_1/",
	"title": "App deployment",
	"tags": [],
	"description": "",
	"content": " Deploy the app kubectl apply -f files/4ingress/1arcadia_delpoy.yaml Output\ndeployment.apps/arcadia-db created\rservice/arcadia-db created\rdeployment.apps/arcadia-frontend created\rservice/arcadia-frontend created\rdeployment.apps/arcadia-login created\rservice/arcadia-login created\rdeployment.apps/arcadia-stock-transaction created\rservice/arcadia-stock-transaction created\rdeployment.apps/arcadia-stocks created\rservice/arcadia-stocks created\rdeployment.apps/arcadia-users created\rservice/arcadia-users created\rCheck that all is deployed and working as expected: kubectl get pods Output\nNAME READY STATUS RESTARTS AGE\rarcadia-db-696f979799-sdzb6 1/1 Running 0 36s\rarcadia-frontend-57ff4f888-v4ggh 1/1 Running 0 36s\rarcadia-login-c995f8dcc-7gvvp 1/1 Running 0 35s\rarcadia-stock-transaction-b996cddb9-xzckf 1/1 Running 0 34s\rarcadia-stocks-dd58548f7-k7tg7 1/1 Running 0 34s\rarcadia-users-768dddd844-8s75q 1/1 Running 0 33s\rkubectl get svc -owide Output\nNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE SELECTOR\rarcadia-db ClusterIP 172.20.180.18 \u0026lt;none\u0026gt; 27017/TCP 74s app=arcadia-db\rarcadia-frontend ClusterIP 172.20.11.202 \u0026lt;none\u0026gt; 80/TCP 73s app=arcadia-frontend\rarcadia-login ClusterIP 172.20.247.63 \u0026lt;none\u0026gt; 80/TCP 73s app=arcadia-login\rarcadia-stock-transaction ClusterIP 172.20.155.246 \u0026lt;none\u0026gt; 80/TCP 72s app=arcadia-stock-transaction\rarcadia-stocks ClusterIP 172.20.23.237 \u0026lt;none\u0026gt; 80/TCP 71s app=arcadia-stocks\rarcadia-users ClusterIP 172.20.73.208 \u0026lt;none\u0026gt; 80/TCP 71s app=arcadia-users\rkubernetes ClusterIP 172.20.0.1 \u0026lt;none\u0026gt; 443/TCP 7m2s \u0026lt;none\u0026gt; The application is not accessible yet. We will deploy the NGINX Ingress in the following sections.\n"
},
{
	"uri": "/060_security/010_elk_deployment/",
	"title": "ELK deployment",
	"tags": [],
	"description": "",
	"content": " Deploy ELK in order to be able to visualize and analyze the traffic going through the Nginx App Protect web application firewall kubectl apply -f files/6waf/elk.yaml In order to connect to our ELK pod, we will need to find the public address of this service: kubectl get svc elk-web Output\nNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE\relk-web LoadBalancer 172.20.179.34 a28bd2d8c94214ae0b512274daa06211-2103709514.eu-central-1.elb.amazonaws.com 5601:32471/TCP,9200:32589/TCP,5044:31876/TCP 16h\r3. Verify that ELK is up and running by browsing to: http://[ELK-EXTERNAL-IP]:5601/.\nPlease note that it might take some time for the DNS name to become available.\n"
},
{
	"uri": "/040_ingress/010_ingress_install_1/",
	"title": "Nginx Kubernetes Ingress Installation",
	"tags": [],
	"description": "",
	"content": "We are going to use the Nginx Helm installation.\nRun the command bellow: kubectl create ns nginx-ingress\rhelm install nginx-ingress nginx-stable/nginx-ingress -f /home/ubuntu/lab/files/4ingress/helm_ingress_values.yaml -n nginx-ingress Output\nNAME: nginx-ingress\rLAST DEPLOYED: Sun Mar 5 10:47:01 2023\rNAMESPACE: nginx-ingress\rSTATUS: deployed\rREVISION: 1\rTEST SUITE: None\rNOTES:\rThe NGINX Ingress Controller has been installed.\rExpose the Nginx Ingress Dashboard. cat \u0026lt;\u0026lt; EOF | kubectl apply -f -\rapiVersion: v1\rkind: Service\rmetadata:\rname: dashboard-nginx-ingress\rnamespace: nginx-ingress\rannotations:\rservice.beta.kubernetes.io/aws-load-balancer-backend-protocol: \u0026#34;tcp\u0026#34;\rservice.beta.kubernetes.io/aws-load-balancer-type: nlb\rspec:\rtype: LoadBalancer\rports:\r- port: 80\rtargetPort: 8080\rprotocol: TCP\rname: http\rselector:\rapp: nginx-ingress-nginx-ingress\rEOF Check what we did so far is actually working: kubectl get svc --namespace=nginx-ingress Output\nNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE\rdashboard-nginx-ingress LoadBalancer 172.20.36.60 aeb592ad4011544219c0bc49581baa13-421891138.eu-central-1.elb.amazonaws.com 80:32044/TCP 11m\rnginx-ingress LoadBalancer 172.20.14.206 ab21b88fec1f445d98c79398abc2cd5d-961716132.eu-central-1.elb.amazonaws.com 80:30284/TCP,443:31110/TCP 5h35m\rNote the EXTERNAL-IP of the \u0026ldquo;dashboard-nginx-ingress\u0026rdquo;. This is the hostname that we are going to use in order to view the Nginx Dashboard.\nBrowse to the following location and verify you can see the dashboard: http://\u0026lt;DASHBOARD-EXTERNAL-IP\u0026gt;/dashboard.html\nNote the EXTERNAL-IP of the \u0026ldquo;nginx-ingress\u0026rdquo;. This is the hostname that we are going to use in order to publish the Arcadia web application.\nBrowse to the following location and verify that you receive a 404 status code: http://\u0026lt;INGRESS-EXTERNAL-IP\u0026gt;/\nPlease note that it might take some time for the DNS names to become available.\nSave the EXTERNAL-IPs as env variables for later use dingress=$(kubectl get svc dashboard-nginx-ingress --namespace=nginx-ingress | tr -s \u0026#34; \u0026#34; | cut -d\u0026#39; \u0026#39; -f4 | grep -v \u0026#34;EXTERNAL-IP\u0026#34;)\recho \u0026#34;export dashboard_nginx_ingress=$dingress\u0026#34; \u0026gt;\u0026gt; ~/.bashrc ningress=$(kubectl get svc nginx-ingress-nginx-ingress --namespace=nginx-ingress | tr -s \u0026#34; \u0026#34; | cut -d\u0026#39; \u0026#39; -f4 | grep -v \u0026#34;EXTERNAL-IP\u0026#34;)\recho \u0026#34;export nginx_ingress=$ningress\u0026#34; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc "
},
{
	"uri": "/020_terraform/010_terraform_apply_1/",
	"title": "Terraform Apply",
	"tags": [],
	"description": "",
	"content": " All configuration and management of the infrastructure will be done from the Jumphost.\nSSH into the Jumphost.\nWatch the terraform deployment status.\ntail -f startup/startup.log When the the ALL IS DONE message will appear in the logs you can continue.\n"
},
{
	"uri": "/010_intro/",
	"title": "Intro to the workshop",
	"tags": [],
	"description": "",
	"content": "Intro to the workshop\nThis workshop will provide guidelines on how to deploy an application from scratch in Amazon Elastic Kubernetes Service environment while protecting and enhancing the application availability and usability with Nginx solutions.\nFor this workshop we are going to use the \u0026ldquo;Arcadia Crypto\u0026rdquo; application. The application is built with 6 different microservices that are deployed in the Kubernetes environment.\nBy the end of the workshop the \u0026ldquo;Arcadia Crypto\u0026rdquo; will be fully deployed and protected as described in the bellow diagram.\n"
},
{
	"uri": "/020_terraform/020_eks_1/",
	"title": "AWS EKS",
	"tags": [],
	"description": "",
	"content": "While you wait, you can review the Introduction section of the AWS EKS Workshop to learn about Kubernetes and Amazon EKS basics.\nManaged control plane Amazon EKS provides a scalable and highly-available control plane that runs across multiple AWS availability zones. The Amazon EKS service automatically manages the availability and scalability of the Kubernetes API servers and the etcd persistence layer for each cluster. Amazon EKS runs the Kubernetes control plane across three Availability Zones in order to ensure high availability, and it automatically detects and replaces unhealthy masters.\nManaged worker nodes Amazon EKS lets you create, update, or terminate worker nodes for your cluster with a single command. Managed node groups run nodes using the latest EKS-optimized AMIs in your AWS account while updates and terminations gracefully drain nodes to ensure your applications stay available.\n"
},
{
	"uri": "/020_terraform/",
	"title": "Deploy NGINX infrastructure using Terraform",
	"tags": [],
	"description": "",
	"content": "The UDF a startup script will automatically deploy the EKS cluster and the Nginx Controller.\n"
},
{
	"uri": "/060_security/020_nap_deployment/",
	"title": "Nginx App Protect deployment",
	"tags": [],
	"description": "",
	"content": " Prepare the Nginx App Protect config export elk_log=$(kubectl get svc elk-log | tr -s \u0026#34; \u0026#34; | cut -d\u0026#39; \u0026#39; -f3 | grep -v \u0026#34;CLUSTER-IP\u0026#34;)\rcat \u0026lt;\u0026lt; EOF | kubectl apply -f -\r# APPolicy is the policy configuration. Here we are enabling signature check of known attacks\rapiVersion: appprotect.f5.com/v1beta1\rkind: APPolicy\rmetadata: name: attacksigs\rspec:\rpolicy:\rname: attacksigs\rtemplate:\rname: POLICY_TEMPLATE_NGINX_BASE\rapplicationLanguage: utf-8\renforcementMode: blocking\rsignature-sets:\r- name: All Signatures\rblock: true\ralarm: true\r---\r# We are going to log to ELK all requests not only the blocked ones\rapiVersion: appprotect.f5.com/v1beta1\rkind: APLogConf\rmetadata:\rname: logconf\rspec:\rcontent:\rformat: default\rmax_message_size: 64k\rmax_request_size: any\rfilter:\rrequest_type: all\r---\r# Creating a generic policy and gluing things together\rapiVersion: k8s.nginx.org/v1\rkind: Policy\rmetadata:\rname: waf-policy\rspec:\rwaf:\renable: true\rapPolicy: \u0026#34;default/attacksigs\u0026#34;\rsecurityLog:\renable: true\rapLogConf: \u0026#34;default/logconf\u0026#34;\rlogDest: \u0026#34;syslog:server=$elk_log:5144\u0026#34;\rEOF Enable Nginx App Protect on the VS cat \u0026lt;\u0026lt; EOF | kubectl apply -f -\rapiVersion: k8s.nginx.org/v1\rkind: VirtualServer\rmetadata:\rname: arcadia\rspec:\rhost: $nginx_ingress tls:\rsecret: arcadia-wildcard # Represents the server certificate\rredirect:\renable: true # Always redirect to https if incoming request is http\r# The bellow waf policy is attachment config\rpolicies: - name: waf-policy\rupstreams:\r- name: arcadia-users\rservice: arcadia-users\rport: 80\rhealthCheck: # This is the most basic healthcheck config for more info follow this link https://docs.nginx.com/nginx-ingress-controller/configuration/virtualserver-and-virtualserverroute-resources/#upstream-healthcheck\renable: true\rpath: /healthz\r- name: arcadia-login\rservice: arcadia-login\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\r- name: arcadia-stocks\rservice: arcadia-stocks\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\r- name: arcadia-stock-transaction\rservice: arcadia-stock-transaction\rport: 80\rhealthCheck: enable: true\rpath: /healthz\r- name: arcadia-frontend\rservice: arcadia-frontend\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\rroutes:\r- path: /v1/user policies:\r- name: jwt-policy\raction:\rproxy:\rupstream: arcadia-users\rrequestHeaders:\rset:\r- name: okta-user\rvalue: \\${jwt_claim_email}\r- path: /v1/login action:\rpass: arcadia-login\r- path: /v1/stock action:\rpass: arcadia-stocks\r- path: /v1/stockt policies:\r- name: jwt-policy\raction:\rproxy:\rupstream: arcadia-stock-transaction\rrequestHeaders:\rset:\r- name: okta-user\rvalue: \\${jwt_claim_email}\r- path: / action:\rpass: arcadia-frontend\rEOF "
},
{
	"uri": "/040_ingress/020_ingress_01/",
	"title": "Publish the app",
	"tags": [],
	"description": "",
	"content": "Expose all the application services and route traffic based on the HTTP path. We will start with a basic configuration.\nExpose Arcadia to the world. cat \u0026lt;\u0026lt; EOF | kubectl apply -f -\rapiVersion: k8s.nginx.org/v1\rkind: VirtualServer\rmetadata:\rname: arcadia\rspec:\rhost: $nginx_ingress upstreams:\r- name: arcadia-users\rservice: arcadia-users\rport: 80\r- name: arcadia-login\rservice: arcadia-login\rport: 80\r- name: arcadia-stocks\rservice: arcadia-stocks\rport: 80\r- name: arcadia-stock-transaction\rservice: arcadia-stock-transaction\rport: 80\r- name: arcadia-frontend\rservice: arcadia-frontend\rport: 80\rroutes:\r- path: /v1/user action:\rpass: arcadia-users\r- path: /v1/login action:\rpass: arcadia-login\r- path: /v1/stock action:\rpass: arcadia-stocks\r- path: /v1/stockt action:\rpass: arcadia-stock-transaction\r- path: / action:\rpass: arcadia-frontend\rEOF Note how the various HTTP paths (/v1/user, /v1/login, /v1/stockt) are routed by Ingress to the relevant K8s services.\nAt this stage the basic install is finished and all that\u0026rsquo;s left is to check the connectivity to the Arcadia web application. Get the public hostname of the exposed nginx-ingress service.\nBrowse to the following location and verify that you can access the site: http://\u0026lt;INGRESS-EXTERNAL-IP\u0026gt;/\nLogin to the application using the following credentials:\nUsername: satoshi@bitcoin.com\nPassword: bitcoin\nAt the moment we still have two key features missing:\nWe are serving only http, not https. We want our site to be fully secured therefore all communications need to be encrypted We are not actively monitoring the health of the pods through the data path Take a look at the files/4ingress/1arcadia_increase.yaml file. It increases the number of pods that our services use.\nApply this new configuration.\nkubectl apply -f files/4ingress/1arcadia_increase.yaml Look at the Nginx dashboard and click on \u0026ldquo;HTTP Upstreams\u0026rdquo;, you can see that right now all services have two members but no health check. "
},
{
	"uri": "/030_application/",
	"title": "Deploy The Arcadia Crypto application",
	"tags": [],
	"description": "",
	"content": "We will deploy our application in the Kubernetes environment.\nAs stated before these are the 6 microservices which we will deploy.\nFrontend - serves the non dynamic content for like html, js, css and images Login - in in charge of dealing with anything related to the login user functionality Users - all user data interaction is done through this microservice only Stocks - connects to external resources to get the latest crypto data and serves it to the application clients Stocks Transaction - Deal with all related to buying or selling crypto currencies. It interact with other microservices like Users and Stocks Database - Database were all information is stored "
},
{
	"uri": "/020_terraform/030_eks_verification_1/",
	"title": "EKS Verification",
	"tags": [],
	"description": "",
	"content": " Check and see that our cluster is up an running.\nBelow we should see our two K8s worker nodes: kubectl get nodes Output\nNAME STATUS ROLES AGE VERSION\rip-10-0-3-204.eu-central-1.compute.internal Ready \u0026lt;none\u0026gt; 100s v1.19.6-eks-49a6c0 Go to the lab directory cd lab "
},
{
	"uri": "/040_ingress/030_health_https_1/",
	"title": "Enable https and monitoring",
	"tags": [],
	"description": "",
	"content": "In our next step we will finish this part of the configuration, we will implement the following:\nEnable health checks Enable https for the application and redirect http requests to https Apply the configuration. cat \u0026lt;\u0026lt; EOF | kubectl apply -f -\rapiVersion: v1\rdata:\rtls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUZMRENDQkJTZ0F3SUJBZ0lTQTUrVmpoQmN3NUJKNWk0QXU2VGl0L3h0TUEwR0NTcUdTSWIzRFFFQkN3VUEKTURJeEN6QUpCZ05WQkFZVEFsVlRNUll3RkFZRFZRUUtFdzFNWlhRbmN5QkZibU55ZVhCME1Rc3dDUVlEVlFRRApFd0pTTXpBZUZ3MHlNVEF4TVRjeE1USXpNek5hRncweU1UQTBNVGN4TVRJek16TmFNQjR4SERBYUJnTlZCQU1NCkV5b3VZWEpqWVdScFlXTnllWEIwYnk1dVpYUXdnZ0VpTUEwR0NTcUdTSWIzRFFFQkFRVUFBNElCRHdBd2dnRUsKQW9JQkFRRE1LQkNYWHdaL0xQbzNmM2pMR3IvamhNRXNTZmdrT3ErOGtOUEpxVzdPbGtCazRrZWtlaEtFVVVDQwowUHdUazgrbnp0Skg3bzBEOUNaaEZuVW9pSGVnZkRzTURFNWFoVXh4blQ1czlmWHZvRlJqSnlYUUR0VlhvR1VQCk1ubzJlVkdYYi81Qm1LeVNJMDVpQ3B5SCtNVC9YRHFhd3BhV2ZsTDJ5OXpZK1V2NGlkQVhsZFpDUnBVSEhOV1cKZjhPeUMvcFJiZndhYVYzRDJ6RjFaeHJ6Z2JIcWd3WXpkRHNnYXVkdk56N0pocytDaENxL1JQNWhMSGNkNzV5bQo1bmppTFZsVmcvYUZJS09IT2wyZ1RFdnQ4WWdjTXdUSWgwNjRrcWpVS3g5UDBmQkpZSzNwV0ZoelhwaENHaWd1CjdTd3EyYnpGTkZabjY1SEdtSDBJY1RLMVlNSm5BZ01CQUFHamdnSk9NSUlDU2pBT0JnTlZIUThCQWY4RUJBTUMKQmFBd0hRWURWUjBsQkJZd0ZBWUlLd1lCQlFVSEF3RUdDQ3NHQVFVRkJ3TUNNQXdHQTFVZEV3RUIvd1FDTUFBdwpIUVlEVlIwT0JCWUVGSXhRMk9EMjhFWjVaVkNTRmNBTlVLbEdqcTFVTUI4R0ExVWRJd1FZTUJhQUZCUXVzeGUzCldGYkxybEFKUU9ZZnI1MkxGTUxHTUZVR0NDc0dBUVVGQndFQkJFa3dSekFoQmdnckJnRUZCUWN3QVlZVmFIUjAKY0RvdkwzSXpMbTh1YkdWdVkzSXViM0puTUNJR0NDc0dBUVVGQnpBQ2hoWm9kSFJ3T2k4dmNqTXVhUzVzWlc1agpjaTV2Y21jdk1CNEdBMVVkRVFRWE1CV0NFeW91WVhKallXUnBZV055ZVhCMGJ5NXVaWFF3VEFZRFZSMGdCRVV3ClF6QUlCZ1puZ1F3QkFnRXdOd1lMS3dZQkJBR0MzeE1CQVFFd0tEQW1CZ2dyQmdFRkJRY0NBUllhYUhSMGNEb3YKTDJOd2N5NXNaWFJ6Wlc1amNubHdkQzV2Y21jd2dnRUVCZ29yQmdFRUFkWjVBZ1FDQklIMUJJSHlBUEFBZHdCRQpsR1V1c083T3I4UkFCOWlvL2lqQTJ1YUN2dGpMTWJVLzB6T1d0YmFCcUFBQUFYY1FUTzdSQUFBRUF3QklNRVlDCklRQ3hMK0hhdnVOY1kzRU0yNllwN0JEeTA1TW8yTUxreHYrdE5nMHA0QmRVQlFJaEFOT1dIWmR1Z056UHl4MEkKOU5VWHVOL09JaGlnS2RGMjhlMmM0TWV3dVRmVEFIVUE5bHlVTDlGM01DSVVWQmdJTUpSV2p1Tk5FeGt6djk4TQpMeUFMekU3eFpPTUFBQUYzRUV6d3V3QUFCQU1BUmpCRUFpQWwvNEZaL1ZwR1NRV3pwdUc2Q0ljWUdHOG4wM1ZZCmRTQnFxUlFHbWUxdnVnSWdRMXg3cnRqYXhrcDNRd3FweWhYRXJyWjhPN3lIdTF2di9pdFhWR1haZzBjd0RRWUoKS29aSWh2Y05BUUVMQlFBRGdnRUJBSnh0Zmk1NmxxZ1RFUEJ6NE82R2xZclJYOVlnL3Y5cUMwWE1DazFSWlJWRApuRldQcTBQUFRWeWR3UTRsOVZQMWhlaTZhNUY0R2xQOVFzaFk3TS9CRFA0SmgwR3pOYnBCY2h4Slc2MHBuUXEzCjI4WmovNzVhamVycTFxYnEvbXpIZHhGcGVzTkVON3NYbUpzNGsrM1pOeWs3N1lXRVhsb1BDMk9STGM2MmhWWlAKdk1sYXZycmNmYWFGNTYvZkR3QzdRd2JZa3JHQzEycFZ4STMzNlFQSGJrRVE2SDNhWGUweE9Dem4rUnZxdXRMTwpqNjh2UVExWG5LdktLc0dCTVNGM29QaGYxZHZtbi9pZHBtK1RjdFJ3ZmUzTGtrL2JpZEJ2a2pJam5jb05HR1pTCllLSFVybmRzMWpDclRVTnI0RFgwTlY5bFNVOG5jUzdMMFBFOGxuUXYrWjg9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0KLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUVaVENDQTAyZ0F3SUJBZ0lRUUFGMUJJTVVwTWdoaklTcERCYk4zekFOQmdrcWhraUc5dzBCQVFzRkFEQS8KTVNRd0lnWURWUVFLRXh0RWFXZHBkR0ZzSUZOcFoyNWhkSFZ5WlNCVWNuVnpkQ0JEYnk0eEZ6QVZCZ05WQkFNVApEa1JUVkNCU2IyOTBJRU5CSUZnek1CNFhEVEl3TVRBd056RTVNakUwTUZvWERUSXhNRGt5T1RFNU1qRTBNRm93Ck1qRUxNQWtHQTFVRUJoTUNWVk14RmpBVUJnTlZCQW9URFV4bGRDZHpJRVZ1WTNKNWNIUXhDekFKQmdOVkJBTVQKQWxJek1JSUJJakFOQmdrcWhraUc5dzBCQVFFRkFBT0NBUThBTUlJQkNnS0NBUUVBdXdJVktNejJvSlRURHhMcwpqVldTdy9pQzhabW1la0tJcDEwbXFyVXJ1Y1ZNc2ErT2EvbDF5S1BYRDBlVUZGVTFWNHllcUtJNUdmV0NQRUtwClRtNzFPOE11MjQzQXNGenpXVGpuN2M5cDhGb0xHNzdBbENRbGgvbzNjYk1UNXh5czRadnYyK1E3UlZKRmxxbkIKVTg0MHlGTHV0YTd0ajk1Z2NPS2xWS3UyYlE2WHBVQTBheXZUdkdiclpqUjgrbXVMajFjcG1mZ3dGMTI2Y20vNwpnY1d0MG9aWVBSZkg1d203OFN2M2h0ekIybkZkMUVianpLMGx3WWk4WUdkMVpyUHhHUGVpWE9aVC96cUl0a2VsCi94TVk2cGdKZHorZFUvblBBZVgxcG5BWEZLOWpwUCtaczVPZDNGT25CdjVJaFIyaGFhNGxkYnNUekZJRDllMVIKb1l2YkZRSURBUUFCbzRJQmFEQ0NBV1F3RWdZRFZSMFRBUUgvQkFnd0JnRUIvd0lCQURBT0JnTlZIUThCQWY4RQpCQU1DQVlZd1N3WUlLd1lCQlFVSEFRRUVQekE5TURzR0NDc0dBUVVGQnpBQ2hpOW9kSFJ3T2k4dllYQndjeTVwClpHVnVkSEoxYzNRdVkyOXRMM0p2YjNSekwyUnpkSEp2YjNSallYZ3pMbkEzWXpBZkJnTlZIU01FR0RBV2dCVEUKcDdHa2V5eHgrdHZoUzVCMS84UVZZSVdKRURCVUJnTlZIU0FFVFRCTE1BZ0dCbWVCREFFQ0FUQS9CZ3NyQmdFRQpBWUxmRXdFQkFUQXdNQzRHQ0NzR0FRVUZCd0lCRmlKb2RIUndPaTh2WTNCekxuSnZiM1F0ZURFdWJHVjBjMlZ1ClkzSjVjSFF1YjNKbk1Ed0dBMVVkSHdRMU1ETXdNYUF2b0MyR0syaDBkSEE2THk5amNtd3VhV1JsYm5SeWRYTjAKTG1OdmJTOUVVMVJTVDA5VVEwRllNME5TVEM1amNtd3dIUVlEVlIwT0JCWUVGQlF1c3hlM1dGYkxybEFKUU9ZZgpyNTJMRk1MR01CMEdBMVVkSlFRV01CUUdDQ3NHQVFVRkJ3TUJCZ2dyQmdFRkJRY0RBakFOQmdrcWhraUc5dzBCCkFRc0ZBQU9DQVFFQTJVemd5ZldFaURjeDI3c1Q0clA4aTJ0aUVteFl0MGwrUEFLM3FCOG9ZZXZPNEM1ejcwa0gKZWpXRUh4MnRhUERZL2xhQkwyMS9XS1p1TlRZUUhIUEQ1YjF0WGdIWGJuTDdLcUM0MDFkazVWdkNhZFRRc3ZkOApTOE1Yam9oeWM5ejkvRzI5NDhrTGptRTZGbGg5ZERZclZZQTl4Mk8raEVQR09hRU9hMWVlUHluQmdQYXl2VWZMCnFqQnN0ekxoV1ZRTEdBa1hYbU5zKzVablBCeHpESk9MeGhGMkpJYmVRQWNINUgwdFpyVWxvNVpZeU9xQTdzOXAKTzViODVvM0FNL09KK0NrdEZCUXRmdkJoY0pWZDl3dmx3UHNrK3V5T3kySEk3bU54S0tnc0JUdDM3NXRlQTJUdwpVZEhraFZOY3NBS1gxSDdHTk5MT0VBRGtzZDg2d3VvWHZnPT0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=\rtls.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV2UUlCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQktjd2dnU2pBZ0VBQW9JQkFRRE1LQkNYWHdaL0xQbzMKZjNqTEdyL2poTUVzU2Zna09xKzhrTlBKcVc3T2xrQms0a2VrZWhLRVVVQ0MwUHdUazgrbnp0Skg3bzBEOUNaaApGblVvaUhlZ2ZEc01ERTVhaFV4eG5UNXM5Zlh2b0ZSakp5WFFEdFZYb0dVUE1ubzJlVkdYYi81Qm1LeVNJMDVpCkNweUgrTVQvWERxYXdwYVdmbEwyeTl6WStVdjRpZEFYbGRaQ1JwVUhITldXZjhPeUMvcFJiZndhYVYzRDJ6RjEKWnhyemdiSHFnd1l6ZERzZ2F1ZHZOejdKaHMrQ2hDcS9SUDVoTEhjZDc1eW01bmppTFZsVmcvYUZJS09IT2wyZwpURXZ0OFlnY013VEloMDY0a3FqVUt4OVAwZkJKWUszcFdGaHpYcGhDR2lndTdTd3EyYnpGTkZabjY1SEdtSDBJCmNUSzFZTUpuQWdNQkFBRUNnZ0VCQUxlRm1JeUtWb3ZDUWRmYjFoazJIYU1IOXFLNmg3OEJwbkpxK29lQXNPUXkKdXdZMVIxTzZqS1MzYWJkdTUvc3RWM0V4QVdTNk03ZUhKVzBIUkNCQXRORG1mQ256Y2dmN1plR0lDZExuTThMSwpMTEhKUWp1SzZndFFXeWhUSnZ1TENXYUp2VlQ0U3NFL3pibGljcDNrYWlwbm5TTDdvMlQ3ZjlidEljVkdMUjNvCklhNU1SWnZ3ZDRHZzBkakErNUIwNWhXU3lDT3k0OHJFVzVKMUdCdC90eTBlaHhEOVVUVS9nb0ViL1Q1TXY1OVYKMWY2elNjS0lHbTh3emx5UnVZbWZwTkwrYjFkdFVUb1NUdVA5R0loU3FWTFN1NUJpR2RTMk81MFhqOWVUQlFhRgpRZUtrN002dWdjanZtZHdzTW4vdHM1T2pvVjY0bk10QlNWemY1VWhJdm1rQ2dZRUE2aGQwZWFHK3J1TFhKTDQwCncreUVuUDZtTktYQkI3eVNTWkVtck1aOWxGVUFxOVdQUk9pZnQ5Tm1vc1BGWi9QMDNBcWFhb3cxTGJmdjBMMFQKQ0hyNkJZSGhtYkNVTjJ6TExrRjZSVnI4NUhtQUxjdVhyajVEM3pZd3lZVmVJOThzV0RZcGVsaWtnOUFnNUFtagpNc3ZBTnRYRElJQmlXTkFQQzJoWXhORisrTHNDZ1lFQTMwTm15ZDFzSi9UaFJvUFpoK2dMNmZ0S2RySE1EWk1zCjRHZkI5K2FDTDNtR3NwU094MTlHOHJmbG9ZU2xNTE5HdnlZcGo1SGg1aHJnQXc4aGVBS3BFRmxFVTdBcm54dVcKZmwwc2J3RkhwN05pZUZscGFPdzU2Mm9FN3c1M2pPRHBIQ1ZLSFphQ0lHZjVLSS9tQmRuVWZYZ1JzSzExdjZMTwpJaExYMFNSM3FFVUNnWUFscUpaTlJ1NzFGWHNFNXpCMzRHSEpHOUpESC9NNHVtWlNQVzZhVnVnMjU2SFBBdkVrClpjUGovN2RBTWZ4YzU4c1padjlHYXIzWFdBTFZjc1ZRRlBDSjJFWWh3bDFsdVRQS2dqQVlYalhXejVFR1RQMWUKdzVlSm5oOGxIRFp6ME9CQ1pKd3htWGNGMllLaERNZmJVUm5mK0cyR21nQzRSdWhVcm5teFYvNTBKd0tCZ0RmSAo2VWlLTDltVHp5MEZDRFp5ZlhlS04wS01qWVRldnBtYWt0WFRHN2VzejBDUzZWRmF0cWt4MVFlVDBvbm1ZTWlsClNrRDZtOHdYN3R3VXpiSGtTRVV6YUdUWVlTMnhnTm8xZ1VLQ3VWcG04VFZNY1krclpaVXh1ZVhZWVhvclAxS3UKNW1PYUZRenZyVXE3R1NkaEV6djk0YjJZdVJDV0pwWlF5dWNRQzIxWkFvR0FKbnNGeHl4ZmFXajFEVHUxcEttNQpTSHQvL0cyRGZteHhKQ05aTFZMUHJYVDJhWmdrNWQwMW5Zb3dydCtscCtiSXBLc09BS2MxamxtRVNwT2VaTEU1Cmk0UVV0eEs3SnV5dHNNZXdqUCtYdmc3VFNEN3d1bW95Vkh6RS9VOTBYcldPOVJJd1VlZFpmOFg4bjVPNCtaRisKeWpqaWNlcGY1ci9DaFNhZG1jM1RwMFk9Ci0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0K\rkind: Secret\rmetadata:\rname: arcadia-wildcard\rtype: kubernetes.io/tls\r---\rapiVersion: k8s.nginx.org/v1\rkind: VirtualServer\rmetadata:\rname: arcadia\rspec:\rhost: $nginx_ingress tls:\rsecret: arcadia-wildcard # Represents the server certificate\rredirect:\renable: true # Always redirect to https if incoming request is http\rupstreams:\r- name: arcadia-users\rservice: arcadia-users\rport: 80\rhealthCheck: # This is the most basic healthcheck config for more info follow this link https://docs.nginx.com/nginx-ingress-controller/configuration/virtualserver-and-virtualserverroute-resources/#upstream-healthcheck\renable: true\rpath: /healthz\r- name: arcadia-login\rservice: arcadia-login\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\r- name: arcadia-stocks\rservice: arcadia-stocks\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\r- name: arcadia-stock-transaction\rservice: arcadia-stock-transaction\rport: 80\rhealthCheck: enable: true\rpath: /healthz\r- name: arcadia-frontend\rservice: arcadia-frontend\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\rroutes:\r- path: /v1/user action:\rpass: arcadia-users\r- path: /v1/login action:\rpass: arcadia-login\r- path: /v1/stock action:\rpass: arcadia-stocks\r- path: /v1/stockt action:\rpass: arcadia-stock-transaction\r- path: / action:\rpass: arcadia-frontend\rEOF Browse to the Arcadia website with http and you will be automatically redirected to https.\nLook at the Nginx dashboard and observe that Nginx has started monitoring the pods. "
},
{
	"uri": "/060_security/030_nap_test/",
	"title": "Nginx App Protect testing",
	"tags": [],
	"description": "",
	"content": " Browse again to the Arcadia web app and verify that it is still working.\nLet\u0026rsquo;s simulate a Cross Site Scripting (XSS) attack, and make sure it\u0026rsquo;s blocked:\nhttps://\u0026lt;INGRESS-EXTERNAL-IP\u0026gt;/?a=%3Cscript%3Ealert(%27xss%27)%3C/script%3E\nEach of the blocked requests will generate a support ID, save it for later.\nBrowse to the ELK as before and click the \u0026ldquo;Discover\u0026rdquo; button: Here, you\u0026rsquo;ll see all the request logs, allowed and blocked, sent by the Nginx WAF to ELK.\nLet\u0026rsquo;s look for the reason why our attack requests were blocked.\nAdd a filter with the support ID you have received as seen bellow: In the right side of the panel, you can see the full request log and the reason why it was blocked.\nContinue and explore the visualization capabilities of Kibana and log information from Nginx WAF by looking into the next two sections bellow the \u0026ldquo;Discover\u0026rdquo; button (Visualize and Dashboard -\u0026gt; Overview). "
},
{
	"uri": "/040_ingress/040_oidc_1/",
	"title": "Authentication with Openid Connect and Okta",
	"tags": [],
	"description": "",
	"content": "Due to unsecure credentials storage of the application it has been decided to migrate to Okta which will provide user management and authentication without the need to store localy personal information.\nRedeploy the front and microservice to a new version in order to use Openid. cat \u0026lt;\u0026lt; EOF | kubectl apply -f -\rapiVersion: apps/v1\rkind: Deployment\rmetadata:\rname: arcadia-frontend\rspec:\rreplicas: 2\rselector:\rmatchLabels:\rapp: arcadia-frontend\rtemplate:\rmetadata:\rlabels:\rapp: arcadia-frontend\rspec:\rcontainers:\r- name: arcadia-frontend\rimage: sorinboiaf5/arcadia-frontend:oktav0.1\rimagePullPolicy: Always\rports:\r- containerPort: 80\rEOF Next we need to configure our Ingress controller to validate each request based on the JWT token and if valid add a custom header which indicates to the application the user. cat \u0026lt;\u0026lt; EOF | kubectl apply -f -\r# Nginx Policy which will be be used in the Virtual Server to perform the JWT validation\rapiVersion: k8s.nginx.org/v1\rkind: Policy\rmetadata:\rname: jwt-policy\rspec:\rjwt:\rrealm: apis\rjwksURI: https://dev-4525016.okta.com/oauth2/v1/keys\r---\rapiVersion: k8s.nginx.org/v1\rkind: VirtualServer\rmetadata:\rname: arcadia\rspec:\rhost: $nginx_ingress tls:\rsecret: arcadia-wildcard # Represents the server certificate\rredirect:\renable: true # Always redirect to https if incoming request is http\rupstreams:\r- name: arcadia-users\rservice: arcadia-users\rport: 80\rhealthCheck: # This is the most basic healthcheck config for more info follow this link https://docs.nginx.com/nginx-ingress-controller/configuration/virtualserver-and-virtualserverroute-resources/#upstream-healthcheck\renable: true\rpath: /healthz\r- name: arcadia-login\rservice: arcadia-login\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\r- name: arcadia-stocks\rservice: arcadia-stocks\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\r- name: arcadia-stock-transaction\rservice: arcadia-stock-transaction\rport: 80\rhealthCheck: enable: true\rpath: /healthz\r- name: arcadia-frontend\rservice: arcadia-frontend\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\rroutes:\r- path: /v1/user # These directives attach the JWT policy to the route that needs authentication extract the username/email address and add it as a header policies:\r- name: jwt-policy\raction:\rproxy:\rupstream: arcadia-users\rrequestHeaders:\rset:\r- name: okta-user\rvalue: \\${jwt_claim_email}\r- path: /v1/login action:\rpass: arcadia-login\r- path: /v1/stock action:\rpass: arcadia-stocks\r- path: /v1/stockt policies:\r- name: jwt-policy\raction:\rproxy:\rupstream: arcadia-stock-transaction\rrequestHeaders:\rset:\r- name: okta-user\rvalue: \\${jwt_claim_email}\r- path: / action:\rpass: arcadia-frontend\rEOF Next we need to register the application end points to the Openid Connect provider curl https://okta.vltr.nginx-experience.com/okta-update?domain=$nginx_ingress Logout of the Arcadia Crypto application, clear your cache or open the browser in incognito and login with the credentials bellow. The authentication will be done by Okta. Username: satoshi@bitcoin.com\nPassword: 1qaz!@#$\n"
},
{
	"uri": "/060_security/040_bot_protection/",
	"title": "Bot Protection",
	"tags": [],
	"description": "",
	"content": "Our application APIs at the moment are published only for consumption by browsers.\nTherefor we don\u0026rsquo;t want to allow any kind of automated tool to access these endpoints.\nWe are going to block not only malicious bots but also tools like curl.\nTry and access the stock microservice and get data with curl. curl -k https://$nginx_ingress/v1/stock/ticker/all The request will succeed.\nApply the bot config cat \u0026lt;\u0026lt; EOF | kubectl apply -f -\rapiVersion: appprotect.f5.com/v1beta1\rkind: APPolicy\rmetadata: name: attacksigs\rspec:\rpolicy:\rname: attacksigs\rtemplate:\rname: POLICY_TEMPLATE_NGINX_BASE\rapplicationLanguage: utf-8\renforcementMode: blocking\rsignature-sets:\r- name: All Signatures\rblock: true\ralarm: true\r# The bellow config is in charge of defining what bot to block and whom to allow bot-defense:\rsettings:\risEnabled: true\rmitigations:\rclasses:\r- name: trusted-bot\raction: alarm\r- name: untrusted-bot\raction: block\r- name: malicious-bot\raction: block\rEOF Try again in a few seconds to access the stock microservice and get data with curl. curl -k https://$nginx_ingress/v1/stock/ticker/all This time the request has been blocked. Take the Support Id and look for the logs in Kibana\n"
},
{
	"uri": "/040_ingress/",
	"title": "Increase availability, security and application performance with Kubernetes Nginx Ingress",
	"tags": [],
	"description": "",
	"content": "Previously we have deployed the application but did not expose the services.\nWe need to be able to route the requests to the relevant service.\nNginx Kubernetes Ingress to save the day! :) The NGINX Ingress Controller for Kubernetes provides enterprise‑grade delivery services for Kubernetes applications, with benefits for users of both NGINX Open Source and NGINX Plus. With the NGINX Ingress Controller for Kubernetes, you get basic load balancing, SSL/TLS termination, support for URI rewrites, and upstream SSL/TLS encryption. NGINX Plus users additionally get session persistence for stateful applications and JSON Web Token (JWT) authentication for APIs.\n"
},
{
	"uri": "/040_ingress/060_mtls_1/",
	"title": "Mutual TLS",
	"tags": [],
	"description": "",
	"content": "Enabling MTLS on our Nginx Ingress Controller is quite simple.\nCreate the Certificate Secret and a policy to use on the Virtual Server resource cat \u0026lt;\u0026lt; EOF | kubectl apply -f -\rkind: Secret\rmetadata:\rname: ingress-mtls-secret\rapiVersion: v1\rtype: nginx.org/ca\rdata:\rca.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUQvVENDQXVXZ0F3SUJBZ0lVSzdhbU14OFlLWG1BVG51SkZETDlWS2ZUR2ZNd0RRWUpLb1pJaHZjTkFRRUwKQlFBd2dZMHhDekFKQmdOVkJBWVRBbFZUTVFzd0NRWURWUVFJREFKRFFURVdNQlFHQTFVRUJ3d05VMkZ1SUVaeQpZVzVqYVhOamJ6RU9NQXdHQTFVRUNnd0ZUa2RKVGxneEREQUtCZ05WQkFzTUEwdEpRekVXTUJRR0ExVUVBd3dOCmEybGpMbTVuYVc1NExtTnZiVEVqTUNFR0NTcUdTSWIzRFFFSkFSWVVhM1ZpWlhKdVpYUmxjMEJ1WjJsdWVDNWoKYjIwd0hoY05NakF3T1RFNE1qQXlOVEkyV2hjTk16QXdPVEUyTWpBeU5USTJXakNCalRFTE1Ba0dBMVVFQmhNQwpWVk14Q3pBSkJnTlZCQWdNQWtOQk1SWXdGQVlEVlFRSERBMVRZVzRnUm5KaGJtTnBjMk52TVE0d0RBWURWUVFLCkRBVk9SMGxPV0RFTU1Bb0dBMVVFQ3d3RFMwbERNUll3RkFZRFZRUUREQTFyYVdNdWJtZHBibmd1WTI5dE1TTXcKSVFZSktvWklodmNOQVFrQkZoUnJkV0psY201bGRHVnpRRzVuYVc1NExtTnZiVENDQVNJd0RRWUpLb1pJaHZjTgpBUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBTmFINVRzaTZzaUFsU085dEJnYmY3VVRwcWowMUhRTlQ2UjhtQy9pCjhLYXFaSW9XSUdvN2xhTW9xTDYydTc4ay9WOHM2Z0FJaU1DSzBjekFvTFhNSnlJQkxQeTg4Yzdtc2xwZXgxTkEKVmRtMkVTVkN6bVlERE1TT3FpVmszWmpYeC9URmo2QzhNRFhhRkZUWFg1dWdtbWdscnFCWlh0OVI5VVBwVTJMNwo1bEZ0NlJ2R3VGczgvbVZORVR5c1A0SFhCWlh2ZE9mdG1YWUkvK01hOW5CMzIzNjdmcTI0L0RKZ2YvK2xRbUsxCkJLR3poSTZSc1pSSmdWOXdpK1VuZTBYNjlaS2lLOFdXU3lZS252YnRrcHZuTDA2dGNJaXJZNi80UzZ4Sm1HRVQKZEJUNmVxc0NoSUpQUStWSEp5dTROdnV6WmVCUXpGdmMwNytnUGZkVWZra1FXODhDQXdFQUFhTlRNRkV3SFFZRApWUjBPQkJZRUZKUGdhcnFYa00rdEJ0djVhdndTUWhUQmpTU2VNQjhHQTFVZEl3UVlNQmFBRkpQZ2FycVhrTSt0CkJ0djVhdndTUWhUQmpTU2VNQThHQTFVZEV3RUIvd1FGTUFNQkFmOHdEUVlKS29aSWh2Y05BUUVMQlFBRGdnRUIKQUl3WXpoY0s4OWtRL0xGWjZFRHgrQWp2bnJTVSs1cmdwQkgrRjVTNUUyY3pXOE5rNXhySnl0Y0ZUbUtlKzZScwpENHlxeTZSVVFEeWNYaDlPelBjbzgzYTBoeFlCZ1M5MWtJa25wYWF4dndLRDJleWc3UGNnK1lkS1FhZFlMcUY0CmI3cWVtc1FVVkpOWHdkZS9VanRBejlEOTh4dngwM2hQY2Qwb2dzUUhWZ21BZVpFd2l3UzFmTy9WNUE4dTl3MEkKcHlJRTVReXlHcHNpS2dpalpiMmhrS05RVHVJcEhiVnFydVA4eEV6TlFnamhkdS9uUW5OYy9lRUltVUlrQkFUVQpiSHdQc2xwYzVhdVV1TXJxR3lEQ0p2QUJpV3J2SmE3Yi9XcmtDT3FUWVhtR2NGM0w1ZU9FeTBhYkp0M2NNcSs5CnJLTUNVQWlkNG0yNEthWnc3OUk2anNBPQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==\r---\rapiVersion: k8s.nginx.org/v1\rkind: Policy\rmetadata:\rname: ingress-mtls-policy\rspec:\ringressMTLS:\rclientCertSecret: ingress-mtls-secret\rverifyClient: \u0026#34;on\u0026#34;\rverifyDepth: 1\rEOF Attach the MTLS policy to the VS. cat \u0026lt;\u0026lt; EOF | kubectl apply -f -\rapiVersion: k8s.nginx.org/v1\rkind: VirtualServer\rmetadata:\rname: arcadia\rspec:\rhost: $nginx_ingress tls:\rsecret: arcadia-wildcard # Represents the server certificate\rredirect:\renable: true # Always redirect to https if incoming request is http\rpolicies:\r- name: ingress-mtls-policy\rupstreams:\r- name: arcadia-users\rservice: arcadia-users\rport: 80\rhealthCheck: # This is the most basic healthcheck config for more info follow this link https://docs.nginx.com/nginx-ingress-controller/configuration/virtualserver-and-virtualserverroute-resources/#upstream-healthcheck\renable: true\rpath: /healthz\r- name: arcadia-login\rservice: arcadia-login\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\r- name: arcadia-stocks\rservice: arcadia-stocks\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\r- name: arcadia-stock-transaction\rservice: arcadia-stock-transaction\rport: 80\rhealthCheck: enable: true\rpath: /healthz\r- name: arcadia-frontend\rservice: arcadia-frontend\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\rroutes:\r- path: /v1/user # These directives attach the JWT policy to the route that needs authentication extract the username/email address and add it as a header policies:\r- name: jwt-policy\raction:\rproxy:\rupstream: arcadia-users\rrequestHeaders:\rset:\r- name: okta-user\rvalue: \\${jwt_claim_email}\r- path: /v1/login action:\rpass: arcadia-login\r- path: /v1/stock action:\rpass: arcadia-stocks\r- path: /v1/stockt policies:\r- name: jwt-policy\raction:\rproxy:\rupstream: arcadia-stock-transaction\rrequestHeaders:\rset:\r- name: okta-user\rvalue: \\${jwt_claim_email}\r- path: / action:\rpass: arcadia-frontend\rEOF Verify this is actually working by running the bellow command, it will use the client cert/key pair on the Cloud9 instance to authenticate: curl -k https://$nginx_ingress/ --cert ./files/4ingress/client-cert.pem --key ./files/4ingress/client-key.pem We are finished with this part of our experience .\nBefore moving forward reapply the ingress configuration without the mutual tls configuration cat \u0026lt;\u0026lt; EOF | kubectl apply -f -\rapiVersion: k8s.nginx.org/v1\rkind: VirtualServer\rmetadata:\rname: arcadia\rspec:\rhost: $nginx_ingress tls:\rsecret: arcadia-wildcard # Represents the server certificate\rredirect:\renable: true # Always redirect to https if incoming request is http\rupstreams:\r- name: arcadia-users\rservice: arcadia-users\rport: 80\rhealthCheck: # This is the most basic healthcheck config for more info follow this link https://docs.nginx.com/nginx-ingress-controller/configuration/virtualserver-and-virtualserverroute-resources/#upstream-healthcheck\renable: true\rpath: /healthz\r- name: arcadia-login\rservice: arcadia-login\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\r- name: arcadia-stocks\rservice: arcadia-stocks\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\r- name: arcadia-stock-transaction\rservice: arcadia-stock-transaction\rport: 80\rhealthCheck: enable: true\rpath: /healthz\r- name: arcadia-frontend\rservice: arcadia-frontend\rport: 80\rhealthCheck:\renable: true\rpath: /healthz\rroutes:\r- path: /v1/user # These directives attach the JWT policy to the route that needs authentication extract the username/email address and add it as a header policies:\r- name: jwt-policy\raction:\rproxy:\rupstream: arcadia-users\rrequestHeaders:\rset:\r- name: okta-user\rvalue: \\${jwt_claim_email}\r- path: /v1/login action:\rpass: arcadia-login\r- path: /v1/stock action:\rpass: arcadia-stocks\r- path: /v1/stockt policies:\r- name: jwt-policy\raction:\rproxy:\rupstream: arcadia-stock-transaction\rrequestHeaders:\rset:\r- name: okta-user\rvalue: \\${jwt_claim_email}\r- path: / action:\rpass: arcadia-frontend\rEOF "
},
{
	"uri": "/060_security/",
	"title": "Security",
	"tags": [],
	"description": "",
	"content": "The Nginx App Protect will allow to improve the application security posture, especially against OWASP Top 10 attacks.\nThe Nginx App Protect is deployed in the ingress resource therefor is able to see all traffic coming to our application from the outside world.\nWe\u0026rsquo;ll be able to bring security closer to the application and the development cycle and integrate it into CI/CD pipelines. This will allow to minimize false positives, since the web application firewall policy becomes a part of the application and is always tested as such.\n"
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]